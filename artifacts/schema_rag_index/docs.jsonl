{"id": "schema_model:models.assistant_rating.AssistantRating", "doc_type": "schema_model", "text": "Model: AssistantRating (table assistant_ratings) — Assistant rating model - stores user ratings for assistant responses. This model stores user ratings and feedback. Key columns: message id (identifier), simulation id (identifier), session id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: user feedback and ratings, temporal queries and filtering Example queries: 'assistantratings', 'user assistantratings'", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "source_file": "backend/models/assistant_rating.py"}}
{"id": "schema_column:models.assistant_rating.AssistantRating.id", "doc_type": "schema_column", "text": "Column: AssistantRating.id (table assistant_ratings) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_rating.py", "keywords": ["id"]}}
{"id": "query_recipe:assistant_ratings.id", "doc_type": "query_recipe", "text": "Recipe: access id from assistant_ratings. Filter by assistant_ratings.id to find specific records.. Return AssistantRating.id", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.assistant_rating.AssistantRating.message_id", "doc_type": "schema_column", "text": "Column: AssistantRating.message_id (table assistant_ratings) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "message_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_rating.py", "keywords": ["id", "message"]}}
{"id": "query_recipe:assistant_ratings.message_id", "doc_type": "query_recipe", "text": "Recipe: access message_id from assistant_ratings. Filter by assistant_ratings.message_id to find specific records.. Return AssistantRating.message_id", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "message_id", "join_hints": [], "keywords": ["id", "message"], "semantics": null}}
{"id": "schema_column:models.assistant_rating.AssistantRating.simulation_id", "doc_type": "schema_column", "text": "Column: AssistantRating.simulation_id (table assistant_ratings) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_rating.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:assistant_ratings.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from assistant_ratings. Filter by assistant_ratings.simulation_id to find specific records.. Return AssistantRating.simulation_id", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.assistant_rating.AssistantRating.session_id", "doc_type": "schema_column", "text": "Column: AssistantRating.session_id (table assistant_ratings) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_rating.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:assistant_ratings.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from assistant_ratings. Filter by assistant_ratings.session_id to find specific records.. Return AssistantRating.session_id", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.assistant_rating.AssistantRating.rating", "doc_type": "schema_column", "text": "Column: AssistantRating.rating (table assistant_ratings) — integer Used to track or store data field. Required field. Common query patterns: MAX(rating) or MIN(rating) for min/max, WHERE rating > value for numeric filtering.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "rating", "type": "INTEGER", "nullable": false, "source_file": "backend/models/assistant_rating.py", "keywords": ["rating"]}}
{"id": "query_recipe:maximum_rating", "doc_type": "query_recipe", "text": "Recipe: maximum or highest rating. Query assistant_ratings table. Use MAX(rating) to find maximum value. Or use ORDER BY rating DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "rating", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "rating", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_rating", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest rating. Query assistant_ratings table. Use MIN(rating) to find minimum value. Or use ORDER BY rating ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "rating", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "rating", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.assistant_rating.AssistantRating.comment", "doc_type": "schema_column", "text": "Column: AssistantRating.comment (table assistant_ratings) — text Used to track or store data field.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "comment", "type": "TEXT", "nullable": true, "source_file": "backend/models/assistant_rating.py", "keywords": ["comment"]}}
{"id": "schema_column:models.assistant_rating.AssistantRating.created_at", "doc_type": "schema_column", "text": "Column: AssistantRating.created_at (table assistant_ratings) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/assistant_rating.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: assistantrating created at in specific year or date range. Query assistant_ratings table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: assistantrating created at in the last week. Query assistant_ratings table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.assistant_rating.AssistantRating.updated_at", "doc_type": "schema_column", "text": "Column: AssistantRating.updated_at (table assistant_ratings) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/assistant_rating.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: assistantrating updated at recently. Query assistant_ratings table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: assistantrating updated at in the last week. Query assistant_ratings table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_assistant_ratings", "doc_type": "query_recipe", "text": "Recipe: all assistantratings. Query assistant_ratings table. Use SELECT * FROM assistant_ratings or SELECT specific columns. Optionally filter by conditions if specified. Return all records from assistant_ratings.", "metadata": {"model": "AssistantRating", "table": "assistant_ratings", "column": null, "join_hints": [], "keywords": ["all", "assistantrating", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.assistant_studio_trace.AssistantStudioTrace", "doc_type": "schema_model", "text": "Model: AssistantStudioTrace (table assistant_studio_traces) — Persistent storage for Assistant Studio traces with tool call metadata. Key columns: simulation id (identifier), message id (identifier), session id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: temporal queries and filtering", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "source_file": "backend/models/assistant_studio_trace.py"}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.id", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.id (table assistant_studio_traces) — varchar(36) Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "id", "type": "VARCHAR(36)", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["id"]}}
{"id": "query_recipe:assistant_studio_traces.id", "doc_type": "query_recipe", "text": "Recipe: access id from assistant_studio_traces. Filter by assistant_studio_traces.id to find specific records.. Return AssistantStudioTrace.id", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.simulation_id", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.simulation_id (table assistant_studio_traces) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:assistant_studio_traces.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from assistant_studio_traces. Filter by assistant_studio_traces.simulation_id to find specific records.. Return AssistantStudioTrace.simulation_id", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.message_id", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.message_id (table assistant_studio_traces) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "message_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["id", "message"]}}
{"id": "query_recipe:assistant_studio_traces.message_id", "doc_type": "query_recipe", "text": "Recipe: access message_id from assistant_studio_traces. Filter by assistant_studio_traces.message_id to find specific records.. Return AssistantStudioTrace.message_id", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "message_id", "join_hints": [], "keywords": ["id", "message"], "semantics": null}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.session_id", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.session_id (table assistant_studio_traces) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "session_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:assistant_studio_traces.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from assistant_studio_traces. Filter by assistant_studio_traces.session_id to find specific records.. Return AssistantStudioTrace.session_id", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.user_message", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.user_message (table assistant_studio_traces) — text Used to track or store data field. Required field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "user_message", "type": "TEXT", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["message", "user"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.response_content", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.response_content (table assistant_studio_traces) — text Used to track or store data field. Required field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "response_content", "type": "TEXT", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["content", "response"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.system_prompt", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.system_prompt (table assistant_studio_traces) — text Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "system_prompt", "type": "TEXT", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["prompt", "system"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.context_snapshot", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.context_snapshot (table assistant_studio_traces) — JSON object Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "context_snapshot", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["context", "snapshot"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.tool_calls", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.tool_calls (table assistant_studio_traces) — JSON object Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "tool_calls", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["calls", "tool"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.token_usage", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.token_usage (table assistant_studio_traces) — JSON object Used to track or store usage count or frequency.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "token_usage", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["executions", "ran", "run", "runs", "token", "usage", "used"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.timings_ms", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.timings_ms (table assistant_studio_traces) — JSON object Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "timings_ms", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["ms", "timings"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.validation", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.validation (table assistant_studio_traces) — JSON object Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "validation", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["validation"]}}
{"id": "query_recipe:assistant_studio_traces.validation", "doc_type": "query_recipe", "text": "Recipe: access validation from assistant_studio_traces. Filter by assistant_studio_traces.validation to find specific records.. Return AssistantStudioTrace.validation", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "validation", "join_hints": [], "keywords": ["validation"], "semantics": null}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.trace_metadata", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.trace_metadata (table assistant_studio_traces) — JSON object Used to track or store data field.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "trace_metadata", "type": "JSON", "nullable": true, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["metadata", "trace"]}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.created_at", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.created_at (table assistant_studio_traces) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: assistantstudiotrace created at in specific year or date range. Query assistant_studio_traces table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: assistantstudiotrace created at in the last week. Query assistant_studio_traces table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.assistant_studio_trace.AssistantStudioTrace.updated_at", "doc_type": "schema_column", "text": "Column: AssistantStudioTrace.updated_at (table assistant_studio_traces) — datetime Used to track or store timestamp when record was last updated. Required field. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "updated_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/assistant_studio_trace.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: assistantstudiotrace updated at recently. Query assistant_studio_traces table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: assistantstudiotrace updated at in the last week. Query assistant_studio_traces table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_assistant_studio_traces", "doc_type": "query_recipe", "text": "Recipe: all assistantstudiotraces. Query assistant_studio_traces table. Use SELECT * FROM assistant_studio_traces or SELECT specific columns. Optionally filter by conditions if specified. Return all records from assistant_studio_traces.", "metadata": {"model": "AssistantStudioTrace", "table": "assistant_studio_traces", "column": null, "join_hints": [], "keywords": ["all", "assistantstudiotrace", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.auth.UserSession", "doc_type": "schema_model", "text": "Model: UserSession (table user_sessions) — User session model for storing OpenRouter OAuth tokens. This model manages user sessions and authentication. Key columns: session id (identifier), api key id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: user session management, temporal queries and filtering Example queries: 'usersession information', 'active usersessions'", "metadata": {"model": "UserSession", "table": "user_sessions", "source_file": "backend/models/auth.py"}}
{"id": "schema_column:models.auth.UserSession.id", "doc_type": "schema_column", "text": "Column: UserSession.id (table user_sessions) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/auth.py", "keywords": ["id"]}}
{"id": "query_recipe:user_sessions.id", "doc_type": "query_recipe", "text": "Recipe: access id from user_sessions. Filter by user_sessions.id to find specific records.. Return UserSession.id", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.auth.UserSession.session_id", "doc_type": "schema_column", "text": "Column: UserSession.session_id (table user_sessions) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/auth.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:user_sessions.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from user_sessions. Filter by user_sessions.session_id to find specific records.. Return UserSession.session_id", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.auth.UserSession.api_key_id", "doc_type": "schema_column", "text": "Column: UserSession.api_key_id (table user_sessions) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "api_key_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/auth.py", "keywords": ["api", "id", "key"]}}
{"id": "query_recipe:user_sessions.api_key_id", "doc_type": "query_recipe", "text": "Recipe: access api_key_id from user_sessions. Filter by user_sessions.api_key_id to find specific records.. Return UserSession.api_key_id", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "api_key_id", "join_hints": [], "keywords": ["api", "id", "key"], "semantics": null}}
{"id": "schema_column:models.auth.UserSession.openrouter_token_encrypted", "doc_type": "schema_column", "text": "Column: UserSession.openrouter_token_encrypted (table user_sessions) — text Used to track or store data field. Required field.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "openrouter_token_encrypted", "type": "TEXT", "nullable": false, "source_file": "backend/models/auth.py", "keywords": ["encrypted", "openrouter", "token"]}}
{"id": "schema_column:models.auth.UserSession.openrouter_token_iv", "doc_type": "schema_column", "text": "Column: UserSession.openrouter_token_iv (table user_sessions) — varchar Used to track or store data field. Required field.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "openrouter_token_iv", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/auth.py", "keywords": ["iv", "openrouter", "token"]}}
{"id": "schema_column:models.auth.UserSession.selected_model", "doc_type": "schema_column", "text": "Column: UserSession.selected_model (table user_sessions) — varchar Used to track or store data field.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "selected_model", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/auth.py", "keywords": ["model", "selected"]}}
{"id": "schema_column:models.auth.UserSession.created_at", "doc_type": "schema_column", "text": "Column: UserSession.created_at (table user_sessions) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/auth.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: usersession created at in specific year or date range. Query user_sessions table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: usersession created at in the last week. Query user_sessions table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.auth.UserSession.updated_at", "doc_type": "schema_column", "text": "Column: UserSession.updated_at (table user_sessions) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/auth.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: usersession updated at recently. Query user_sessions table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: usersession updated at in the last week. Query user_sessions table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.auth.UserSession.expires_at", "doc_type": "schema_column", "text": "Column: UserSession.expires_at (table user_sessions) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(expires_at) = year for year filtering, WHERE expires_at BETWEEN start AND end for date ranges.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "expires_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/auth.py", "keywords": ["at", "expires"]}}
{"id": "query_recipe:expires_at_last_week", "doc_type": "query_recipe", "text": "Recipe: usersession expires at in the last week. Query user_sessions table. Filter by expires_at >= NOW() - INTERVAL '7' DAYS or WHERE expires_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": "expires_at", "join_hints": [], "keywords": ["at", "expires", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_user_sessions", "doc_type": "query_recipe", "text": "Recipe: all usersessions. Query user_sessions table. Use SELECT * FROM user_sessions or SELECT specific columns. Optionally filter by conditions if specified. Return all records from user_sessions.", "metadata": {"model": "UserSession", "table": "user_sessions", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "usersession"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.chat_message.ChatMessage", "doc_type": "schema_model", "text": "Model: ChatMessage (table chat_messages) — Chat message model - stores chat history for simulations and experiments. This model stores conversation history and message content. Key columns: simulation id (identifier), experiment id (identifier), message id (identifier), session id (identifier), created at (timestamp when record was created) Commonly used for: conversation history, message content retrieval, temporal queries and filtering Example queries: 'chatmessage history', 'chatmessage content'", "metadata": {"model": "ChatMessage", "table": "chat_messages", "source_file": "backend/models/chat_message.py"}}
{"id": "schema_column:models.chat_message.ChatMessage.id", "doc_type": "schema_column", "text": "Column: ChatMessage.id (table chat_messages) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["id"]}}
{"id": "query_recipe:chat_messages.id", "doc_type": "query_recipe", "text": "Recipe: access id from chat_messages. Filter by chat_messages.id to find specific records.. Return ChatMessage.id", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.chat_message.ChatMessage.simulation_id", "doc_type": "schema_column", "text": "Column: ChatMessage.simulation_id (table chat_messages) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:chat_messages.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from chat_messages. Filter by chat_messages.simulation_id to find specific records.. Return ChatMessage.simulation_id", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.chat_message.ChatMessage.experiment_id", "doc_type": "schema_column", "text": "Column: ChatMessage.experiment_id (table chat_messages) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "experiment_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/chat_message.py", "keywords": ["experiment", "id"]}}
{"id": "query_recipe:chat_messages.experiment_id", "doc_type": "query_recipe", "text": "Recipe: access experiment_id from chat_messages. Filter by chat_messages.experiment_id to find specific records.. Return ChatMessage.experiment_id", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "experiment_id", "join_hints": [], "keywords": ["experiment", "id"], "semantics": null}}
{"id": "schema_column:models.chat_message.ChatMessage.message_id", "doc_type": "schema_column", "text": "Column: ChatMessage.message_id (table chat_messages) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "message_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["id", "message"]}}
{"id": "query_recipe:chat_messages.message_id", "doc_type": "query_recipe", "text": "Recipe: access message_id from chat_messages. Filter by chat_messages.message_id to find specific records.. Return ChatMessage.message_id", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "message_id", "join_hints": [], "keywords": ["id", "message"], "semantics": null}}
{"id": "schema_column:models.chat_message.ChatMessage.session_id", "doc_type": "schema_column", "text": "Column: ChatMessage.session_id (table chat_messages) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:chat_messages.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from chat_messages. Filter by chat_messages.session_id to find specific records.. Return ChatMessage.session_id", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.chat_message.ChatMessage.message_type", "doc_type": "schema_column", "text": "Column: ChatMessage.message_type (table chat_messages) — varchar Used to track or store data field. Required field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "message_type", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["message", "type"]}}
{"id": "schema_column:models.chat_message.ChatMessage.content", "doc_type": "schema_column", "text": "Column: ChatMessage.content (table chat_messages) — text Used to track or store data field. Required field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "content", "type": "TEXT", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["content"]}}
{"id": "schema_column:models.chat_message.ChatMessage.message_metadata", "doc_type": "schema_column", "text": "Column: ChatMessage.message_metadata (table chat_messages) — JSON object Used to track or store data field.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "message_metadata", "type": "JSON", "nullable": true, "source_file": "backend/models/chat_message.py", "keywords": ["message", "metadata"]}}
{"id": "schema_column:models.chat_message.ChatMessage.created_at", "doc_type": "schema_column", "text": "Column: ChatMessage.created_at (table chat_messages) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/chat_message.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: chatmessage created at in specific year or date range. Query chat_messages table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: chatmessage created at in the last week. Query chat_messages table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_chat_messages", "doc_type": "query_recipe", "text": "Recipe: all chatmessages. Query chat_messages table. Use SELECT * FROM chat_messages or SELECT specific columns. Optionally filter by conditions if specified. Return all records from chat_messages.", "metadata": {"model": "ChatMessage", "table": "chat_messages", "column": null, "join_hints": [], "keywords": ["all", "chatmessage", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.experiment.Experiment", "doc_type": "schema_model", "text": "Model: Experiment (table experiments) — Experiment model - groups related simulations for hypothesis testing. This model manages experiments and their configurations. Key columns: name (name or label for identification), status (current status or state), created at (timestamp when record was created), updated at (timestamp when record was last updated), research id (identifier) Commonly used for: experiment management and tracking, temporal queries and filtering Example queries: 'experiment details', 'experiment information', 'experiment names', 'experiment status' Relationships: related to research via research, related to simulation via simulations, related to note via note_entries", "metadata": {"model": "Experiment", "table": "experiments", "source_file": "backend/models/experiment.py"}}
{"id": "schema_column:models.experiment.Experiment.id", "doc_type": "schema_column", "text": "Column: Experiment.id (table experiments) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "Experiment", "table": "experiments", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["id"]}}
{"id": "query_recipe:experiments.id", "doc_type": "query_recipe", "text": "Recipe: access id from experiments. Filter by experiments.id to find specific records.. Return Experiment.id", "metadata": {"model": "Experiment", "table": "experiments", "column": "id", "join_hints": ["experiments.research_id -> research.id", "experiments.id -> simulations.experiment_id", "experiments.id -> notes.experiment_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.experiment.Experiment.name", "doc_type": "schema_column", "text": "Column: Experiment.name (table experiments) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "Experiment", "table": "experiments", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:experiments.name", "doc_type": "query_recipe", "text": "Recipe: access name from experiments. Filter by experiments.name to find specific records.. Return Experiment.name", "metadata": {"model": "Experiment", "table": "experiments", "column": "name", "join_hints": ["experiments.research_id -> research.id", "experiments.id -> simulations.experiment_id", "experiments.id -> notes.experiment_id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.experiment.Experiment.description", "doc_type": "schema_column", "text": "Column: Experiment.description (table experiments) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "Experiment", "table": "experiments", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.experiment.Experiment.hypothesis", "doc_type": "schema_column", "text": "Column: Experiment.hypothesis (table experiments) — text Used to track or store data field.", "metadata": {"model": "Experiment", "table": "experiments", "column": "hypothesis", "type": "TEXT", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["hypothesis"]}}
{"id": "schema_column:models.experiment.Experiment.status", "doc_type": "schema_column", "text": "Column: Experiment.status (table experiments) — varchar Used to track or store current status or state. Default: draft. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE status = 'status_value' for filtering, COUNT(*) WHERE status = 'status' for counting by status.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"]}}
{"id": "query_recipe:status_running", "doc_type": "query_recipe", "text": "Recipe: experiment with status running. Query experiments table. Filter by status = 'running' (or appropriate status value). Use COUNT(*) to count how many experiments are running. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:status_completed", "doc_type": "query_recipe", "text": "Recipe: experiment with status completed. Query experiments table. Filter by status = 'completed' (or appropriate status value). Use COUNT(*) to count how many experiments are completed. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:status_active", "doc_type": "query_recipe", "text": "Recipe: experiment with status active. Query experiments table. Filter by status = 'active' (or appropriate status value). Use COUNT(*) to count how many experiments are active. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:status_failed", "doc_type": "query_recipe", "text": "Recipe: experiment with status failed. Query experiments table. Filter by status = 'failed' (or appropriate status value). Use COUNT(*) to count how many experiments are failed. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:status_pending", "doc_type": "query_recipe", "text": "Recipe: experiment with status pending. Query experiments table. Filter by status = 'pending' (or appropriate status value). Use COUNT(*) to count how many experiments are pending. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "pending", "running", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:status_success", "doc_type": "query_recipe", "text": "Recipe: experiment with status success. Query experiments table. Filter by status = 'success' (or appropriate status value). Use COUNT(*) to count how many experiments are success. Return matching records or count.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_status", "doc_type": "query_recipe", "text": "Recipe: how many experiments with specific status. Query experiments table. Use COUNT(*) with filter WHERE status = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "Experiment", "table": "experiments", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "count", "failed", "how many", "number", "running", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.experiment.Experiment.created_at", "doc_type": "schema_column", "text": "Column: Experiment.created_at (table experiments) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "Experiment", "table": "experiments", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: experiment created at in specific year or date range. Query experiments table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "Experiment", "table": "experiments", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: experiment created at in the last week. Query experiments table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Experiment", "table": "experiments", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.experiment.Experiment.updated_at", "doc_type": "schema_column", "text": "Column: Experiment.updated_at (table experiments) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "Experiment", "table": "experiments", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: experiment updated at recently. Query experiments table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "Experiment", "table": "experiments", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: experiment updated at in the last week. Query experiments table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Experiment", "table": "experiments", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.experiment.Experiment.started_at", "doc_type": "schema_column", "text": "Column: Experiment.started_at (table experiments) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(started_at) = year for year filtering, WHERE started_at BETWEEN start AND end for date ranges.", "metadata": {"model": "Experiment", "table": "experiments", "column": "started_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["at", "began", "begin", "initiated", "start", "started"]}}
{"id": "query_recipe:started_at_in_year", "doc_type": "query_recipe", "text": "Recipe: experiment started at in specific year or date range. Query experiments table. Filter by started_at using date functions: WHERE YEAR(started_at) = year or WHERE started_at >= start_date AND started_at <= end_date. Return matching records.", "metadata": {"model": "Experiment", "table": "experiments", "column": "started_at", "join_hints": [], "keywords": ["at", "began", "begin", "created", "date", "in", "initiated", "start", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:started_at_last_week", "doc_type": "query_recipe", "text": "Recipe: experiment started at in the last week. Query experiments table. Filter by started_at >= NOW() - INTERVAL '7' DAYS or WHERE started_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Experiment", "table": "experiments", "column": "started_at", "join_hints": [], "keywords": ["at", "began", "begin", "initiated", "last week", "past", "recent", "since", "start", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.experiment.Experiment.completed_at", "doc_type": "schema_column", "text": "Column: Experiment.completed_at (table experiments) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(completed_at) = year for year filtering, WHERE completed_at BETWEEN start AND end for date ranges.", "metadata": {"model": "Experiment", "table": "experiments", "column": "completed_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["at", "complete", "completed", "done", "ended", "finished"]}}
{"id": "query_recipe:completed_at_last_week", "doc_type": "query_recipe", "text": "Recipe: experiment completed at in the last week. Query experiments table. Filter by completed_at >= NOW() - INTERVAL '7' DAYS or WHERE completed_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Experiment", "table": "experiments", "column": "completed_at", "join_hints": [], "keywords": ["at", "complete", "completed", "done", "ended", "finished", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.experiment.Experiment.base_parameters", "doc_type": "schema_column", "text": "Column: Experiment.base_parameters (table experiments) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "Experiment", "table": "experiments", "column": "base_parameters", "type": "JSON", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["base", "parameters"]}}
{"id": "schema_column:models.experiment.Experiment.parameter_variations", "doc_type": "schema_column", "text": "Column: Experiment.parameter_variations (table experiments) — JSON object Used to track or store data field.", "metadata": {"model": "Experiment", "table": "experiments", "column": "parameter_variations", "type": "JSON", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["parameter", "variations"]}}
{"id": "schema_column:models.experiment.Experiment.assumptions", "doc_type": "schema_column", "text": "Column: Experiment.assumptions (table experiments) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "Experiment", "table": "experiments", "column": "assumptions", "type": "JSON", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["assumptions"]}}
{"id": "schema_column:models.experiment.Experiment.metrics", "doc_type": "schema_column", "text": "Column: Experiment.metrics (table experiments) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "Experiment", "table": "experiments", "column": "metrics", "type": "JSON", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["metrics"]}}
{"id": "schema_column:models.experiment.Experiment.tags", "doc_type": "schema_column", "text": "Column: Experiment.tags (table experiments) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "Experiment", "table": "experiments", "column": "tags", "type": "JSON", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["tags"]}}
{"id": "schema_column:models.experiment.Experiment.notes", "doc_type": "schema_column", "text": "Column: Experiment.notes (table experiments) — text Used to track or store data field.", "metadata": {"model": "Experiment", "table": "experiments", "column": "notes", "type": "TEXT", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["notes"]}}
{"id": "schema_column:models.experiment.Experiment.target_iterations", "doc_type": "schema_column", "text": "Column: Experiment.target_iterations (table experiments) — integer Used to track or store data field. Default: 1. Common query patterns: MAX(target_iterations) or MIN(target_iterations) for min/max, WHERE target_iterations > value for numeric filtering.", "metadata": {"model": "Experiment", "table": "experiments", "column": "target_iterations", "type": "INTEGER", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["iterations", "target"]}}
{"id": "query_recipe:maximum_target_iterations", "doc_type": "query_recipe", "text": "Recipe: maximum or highest target iterations. Query experiments table. Use MAX(target_iterations) to find maximum value. Or use ORDER BY target_iterations DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Experiment", "table": "experiments", "column": "target_iterations", "join_hints": [], "keywords": ["best", "highest", "iterations", "max", "maximum", "most", "target", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_target_iterations", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest target iterations. Query experiments table. Use MIN(target_iterations) to find minimum value. Or use ORDER BY target_iterations ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Experiment", "table": "experiments", "column": "target_iterations", "join_hints": [], "keywords": ["iterations", "least", "lowest", "min", "minimum", "smallest", "target"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.experiment.Experiment.completed_iterations", "doc_type": "schema_column", "text": "Column: Experiment.completed_iterations (table experiments) — integer Used to track or store data field. Default: 0. Common query patterns: MAX(completed_iterations) or MIN(completed_iterations) for min/max, WHERE completed_iterations > value for numeric filtering.", "metadata": {"model": "Experiment", "table": "experiments", "column": "completed_iterations", "type": "INTEGER", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["complete", "completed", "done", "ended", "finished", "iterations"]}}
{"id": "query_recipe:maximum_completed_iterations", "doc_type": "query_recipe", "text": "Recipe: maximum or highest completed iterations. Query experiments table. Use MAX(completed_iterations) to find maximum value. Or use ORDER BY completed_iterations DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Experiment", "table": "experiments", "column": "completed_iterations", "join_hints": [], "keywords": ["best", "complete", "completed", "done", "ended", "finished", "highest", "iterations", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_completed_iterations", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest completed iterations. Query experiments table. Use MIN(completed_iterations) to find minimum value. Or use ORDER BY completed_iterations ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Experiment", "table": "experiments", "column": "completed_iterations", "join_hints": [], "keywords": ["complete", "completed", "done", "ended", "finished", "iterations", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.experiment.Experiment.success_criteria", "doc_type": "schema_column", "text": "Column: Experiment.success_criteria (table experiments) — JSON object Used to track or store number of successful operations.", "metadata": {"model": "Experiment", "table": "experiments", "column": "success_criteria", "type": "JSON", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["criteria", "succeeded", "success", "win", "wins"]}}
{"id": "schema_column:models.experiment.Experiment.results_summary", "doc_type": "schema_column", "text": "Column: Experiment.results_summary (table experiments) — JSON object Used to track or store data field.", "metadata": {"model": "Experiment", "table": "experiments", "column": "results_summary", "type": "JSON", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["results", "summary"]}}
{"id": "schema_column:models.experiment.Experiment.research_id", "doc_type": "schema_column", "text": "Column: Experiment.research_id (table experiments) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "Experiment", "table": "experiments", "column": "research_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["id", "research"]}}
{"id": "query_recipe:experiments.research_id", "doc_type": "query_recipe", "text": "Recipe: access research_id from experiments. Filter by experiments.research_id to find specific records.. Return Experiment.research_id", "metadata": {"model": "Experiment", "table": "experiments", "column": "research_id", "join_hints": ["experiments.research_id -> research.id", "experiments.id -> simulations.experiment_id", "experiments.id -> notes.experiment_id"], "keywords": ["id", "research"], "semantics": null}}
{"id": "query_recipe:experiments_linked_to_research", "doc_type": "query_recipe", "text": "Recipe: experiments linked to research. Join research to experiments on research.id = experiments.research_id. Filter by research.name or research.id if specific research project requested. Return experiments.name, experiments.status, and research.name. This shows all experiments associated with a research project.", "metadata": {"model": "Experiment", "table": "experiments", "column": "research_id", "join_hints": ["experiments.research_id -> research.id", "research.name (optional filter)"], "keywords": ["experiments", "linked", "to", "research", "related", "associated", "for"], "semantics": "Relationship query: experiments for research", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:research_for_experiments", "doc_type": "query_recipe", "text": "Recipe: research for experiment. Join research to experiments on experiments.research_id -> research.id. Filter by experiments fields to find specific experiment. Return related research records.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["experiments.research_id -> research.id"], "keywords": ["associated", "belongs", "experiment", "for", "research"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_linked_to_simulations", "doc_type": "query_recipe", "text": "Recipe: experiment linked to simulation. Join experiments to simulations on experiments.id -> simulations.experiment_id. Filter by experiments fields to find specific records. Return related simulations records or simulations fields.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["experiments.id -> simulations.experiment_id"], "keywords": ["connection", "linked", "related", "relationship", "simulation", "simulations"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:simulations_for_experiments", "doc_type": "query_recipe", "text": "Recipe: simulation for experiment. Join simulations to experiments on experiments.id -> simulations.experiment_id. Filter by experiments fields to find specific experiment. Return related simulations records.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": ["experiments.id -> simulations.experiment_id"], "keywords": ["associated", "belongs", "experiment", "for", "simulation"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_linked_to_notes", "doc_type": "query_recipe", "text": "Recipe: experiment linked to note. Join experiments to notes on experiments.id -> notes.experiment_id. Filter by experiments fields to find specific records. Return related notes records or notes fields.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["experiments.id -> notes.experiment_id"], "keywords": ["connection", "entries", "linked", "note", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:notes_for_experiments", "doc_type": "query_recipe", "text": "Recipe: notes for experiments. Join experiments to notes on experiments.id = notes.experiment_id. Filter by experiments.name or experiments.id if specific experiment requested. Return notes.content, notes.created_at, and experiments.name. Order by notes.created_at DESC to show most recent notes first.", "metadata": {"model": "Note", "table": "notes", "column": "experiment_id", "join_hints": ["notes.experiment_id -> experiments.id", "experiments.name (optional filter)"], "keywords": ["notes", "for", "experiments", "related", "linked", "associated"], "semantics": "Relationship query: notes for experiments", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:list_all_experiments_names", "doc_type": "query_recipe", "text": "Recipe: list all experiment names. Query experiments table. Use SELECT name FROM experiments. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "Experiment", "table": "experiments", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:experiments_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: experiment names and descriptions. Query experiments table. Use SELECT name, description FROM experiments. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_experiments", "doc_type": "query_recipe", "text": "Recipe: all experiments. Query experiments table. Use SELECT * FROM experiments or SELECT specific columns. Optionally filter by conditions if specified. Return all records from experiments.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": [], "keywords": ["all", "every", "experiment", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.experiment.ExperimentSimulation", "doc_type": "schema_model", "text": "Model: ExperimentSimulation (table experiment_simulations) — Links experiments to simulations with iteration-specific parameters. This model tracks simulation executions, status, and results. Key columns: experiment id (identifier), simulation id (identifier), created at (timestamp when record was created) Commonly used for: simulation execution tracking, temporal queries and filtering Example queries: 'experimentsimulation status', 'experimentsimulation information' Relationships: related to experiment via experiment, related to simulation via simulation", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "source_file": "backend/models/experiment.py"}}
{"id": "schema_column:models.experiment.ExperimentSimulation.id", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.id (table experiment_simulations) — integer Used to track or store data field. Required field. Common query patterns: MAX(id) or MIN(id) for min/max, WHERE id > value for numeric filtering.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "id", "type": "INTEGER", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["id"]}}
{"id": "query_recipe:experiment_simulations.id", "doc_type": "query_recipe", "text": "Recipe: access id from experiment_simulations. Filter by experiment_simulations.id to find specific records.. Return ExperimentSimulation.id", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "id", "join_hints": ["experiment_simulations.experiment_id -> experiments.id", "experiment_simulations.simulation_id -> simulations.id"], "keywords": ["id"], "semantics": null}}
{"id": "query_recipe:maximum_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest id. Query experiment_simulations table. Use MAX(id) to find maximum value. Or use ORDER BY id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest id. Query experiment_simulations table. Use MIN(id) to find minimum value. Or use ORDER BY id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.experiment.ExperimentSimulation.experiment_id", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.experiment_id (table experiment_simulations) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "experiment_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["experiment", "id"]}}
{"id": "query_recipe:experiment_simulations.experiment_id", "doc_type": "query_recipe", "text": "Recipe: access experiment_id from experiment_simulations. Filter by experiment_simulations.experiment_id to find specific records.. Return ExperimentSimulation.experiment_id", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "experiment_id", "join_hints": ["experiment_simulations.experiment_id -> experiments.id", "experiment_simulations.simulation_id -> simulations.id"], "keywords": ["experiment", "id"], "semantics": null}}
{"id": "schema_column:models.experiment.ExperimentSimulation.simulation_id", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.simulation_id (table experiment_simulations) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:experiment_simulations.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from experiment_simulations. Filter by experiment_simulations.simulation_id to find specific records.. Return ExperimentSimulation.simulation_id", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "simulation_id", "join_hints": ["experiment_simulations.experiment_id -> experiments.id", "experiment_simulations.simulation_id -> simulations.id"], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.experiment.ExperimentSimulation.iteration", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.iteration (table experiment_simulations) — integer Used to track or store data field. Required field. Common query patterns: MAX(iteration) or MIN(iteration) for min/max, WHERE iteration > value for numeric filtering.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "iteration", "type": "INTEGER", "nullable": false, "source_file": "backend/models/experiment.py", "keywords": ["iteration"]}}
{"id": "query_recipe:maximum_iteration", "doc_type": "query_recipe", "text": "Recipe: maximum or highest iteration. Query experiment_simulations table. Use MAX(iteration) to find maximum value. Or use ORDER BY iteration DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "iteration", "join_hints": [], "keywords": ["best", "highest", "iteration", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_iteration", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest iteration. Query experiment_simulations table. Use MIN(iteration) to find minimum value. Or use ORDER BY iteration ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "iteration", "join_hints": [], "keywords": ["iteration", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.experiment.ExperimentSimulation.parameters_override", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.parameters_override (table experiment_simulations) — JSON object Used to track or store data field.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "parameters_override", "type": "JSON", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["override", "parameters"]}}
{"id": "query_recipe:experiment_simulations.parameters_override", "doc_type": "query_recipe", "text": "Recipe: access parameters_override from experiment_simulations. Filter by experiment_simulations.parameters_override to find specific records.. Return ExperimentSimulation.parameters_override", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "parameters_override", "join_hints": ["experiment_simulations.experiment_id -> experiments.id", "experiment_simulations.simulation_id -> simulations.id"], "keywords": ["override", "parameters"], "semantics": null}}
{"id": "schema_column:models.experiment.ExperimentSimulation.created_at", "doc_type": "schema_column", "text": "Column: ExperimentSimulation.created_at (table experiment_simulations) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/experiment.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: experimentsimulation created at in specific year or date range. Query experiment_simulations table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: experimentsimulation created at in the last week. Query experiment_simulations table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:experiment_simulations_linked_to_experiments", "doc_type": "query_recipe", "text": "Recipe: experimentsimulation linked to experiment. Join experiment_simulations to experiments on experiment_simulations.experiment_id -> experiments.id. Filter by experiment_simulations fields to find specific records. Return related experiments records or experiments fields.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": null, "join_hints": ["experiment_simulations.experiment_id -> experiments.id"], "keywords": ["connection", "experiment", "linked", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_for_experiment_simulations", "doc_type": "query_recipe", "text": "Recipe: experiment for experimentsimulation. Join experiments to experiment_simulations on experiment_simulations.experiment_id -> experiments.id. Filter by experiment_simulations fields to find specific experimentsimulation. Return related experiments records.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["experiment_simulations.experiment_id -> experiments.id"], "keywords": ["associated", "belongs", "experiment", "experimentsimulation", "for"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiment_simulations_linked_to_simulations", "doc_type": "query_recipe", "text": "Recipe: experimentsimulation linked to simulation. Join experiment_simulations to simulations on experiment_simulations.simulation_id -> simulations.id. Filter by experiment_simulations fields to find specific records. Return related simulations records or simulations fields.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": null, "join_hints": ["experiment_simulations.simulation_id -> simulations.id"], "keywords": ["connection", "linked", "related", "relationship", "simulation"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:simulations_for_experiment_simulations", "doc_type": "query_recipe", "text": "Recipe: simulation for experimentsimulation. Join simulations to experiment_simulations on experiment_simulations.simulation_id -> simulations.id. Filter by experiment_simulations fields to find specific experimentsimulation. Return related simulations records.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": ["experiment_simulations.simulation_id -> simulations.id"], "keywords": ["associated", "belongs", "experimentsimulation", "for", "simulation"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_experiment_simulations", "doc_type": "query_recipe", "text": "Recipe: all experimentsimulations. Query experiment_simulations table. Use SELECT * FROM experiment_simulations or SELECT specific columns. Optionally filter by conditions if specified. Return all records from experiment_simulations.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": null, "join_hints": [], "keywords": ["all", "every", "experimentsimulation", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.research.Research", "doc_type": "schema_model", "text": "Model: Research (table research) — Research model - top-level container for related experiments. This model stores research goals, questions, and related information. Key columns: name (name or label for identification), sub name (name or label for identification), status (current status or state), session id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: research goals and questions, temporal queries and filtering Example queries: 'research goals', 'research questions', 'research names', 'research status' Relationships: related to experiment via experiments, related to researchquestion via research_questions, related to note via note_entries", "metadata": {"model": "Research", "table": "research", "source_file": "backend/models/research.py"}}
{"id": "schema_column:models.research.Research.id", "doc_type": "schema_column", "text": "Column: Research.id (table research) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "Research", "table": "research", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["id"]}}
{"id": "query_recipe:research.id", "doc_type": "query_recipe", "text": "Recipe: access id from research. Filter by research.id to find specific records.. Return Research.id", "metadata": {"model": "Research", "table": "research", "column": "id", "join_hints": ["research.id -> experiments.research_id", "research.id -> research_questions.research_id", "research.id -> notes.research_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.research.Research.name", "doc_type": "schema_column", "text": "Column: Research.name (table research) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "Research", "table": "research", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:research.name", "doc_type": "query_recipe", "text": "Recipe: access name from research. Filter by research.name to find specific records.. Return Research.name", "metadata": {"model": "Research", "table": "research", "column": "name", "join_hints": ["research.id -> experiments.research_id", "research.id -> research_questions.research_id", "research.id -> notes.research_id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.research.Research.sub_name", "doc_type": "schema_column", "text": "Column: Research.sub_name (table research) — varchar name or label Used to track or store name or label for identification. Common query patterns: WHERE sub_name = 'value' for exact match, WHERE sub_name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "Research", "table": "research", "column": "sub_name", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["label", "labels", "name", "names", "sub", "title", "titles"]}}
{"id": "query_recipe:research.sub_name", "doc_type": "query_recipe", "text": "Recipe: access sub_name from research. Filter by research.sub_name to find specific records.. Return Research.sub_name", "metadata": {"model": "Research", "table": "research", "column": "sub_name", "join_hints": ["research.id -> experiments.research_id", "research.id -> research_questions.research_id", "research.id -> notes.research_id"], "keywords": ["label", "labels", "name", "names", "sub", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.research.Research.description", "doc_type": "schema_column", "text": "Column: Research.description (table research) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "Research", "table": "research", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.research.Research.goals", "doc_type": "schema_column", "text": "Column: Research.goals (table research) — JSON object Used to track or store data field. Default: function list.", "metadata": {"model": "Research", "table": "research", "column": "goals", "type": "JSON", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["goals"]}}
{"id": "schema_column:models.research.Research.tags", "doc_type": "schema_column", "text": "Column: Research.tags (table research) — JSON object Used to track or store data field. Default: function list.", "metadata": {"model": "Research", "table": "research", "column": "tags", "type": "JSON", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["tags"]}}
{"id": "schema_column:models.research.Research.status", "doc_type": "schema_column", "text": "Column: Research.status (table research) — varchar Used to track or store current status or state. Default: active. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE status = 'status_value' for filtering, COUNT(*) WHERE status = 'status' for counting by status.", "metadata": {"model": "Research", "table": "research", "column": "status", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"]}}
{"id": "query_recipe:status_running", "doc_type": "query_recipe", "text": "Recipe: research with status running. Query research table. Filter by status = 'running' (or appropriate status value). Use COUNT(*) to count how many researchs are running. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:status_completed", "doc_type": "query_recipe", "text": "Recipe: research with status completed. Query research table. Filter by status = 'completed' (or appropriate status value). Use COUNT(*) to count how many researchs are completed. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:status_active", "doc_type": "query_recipe", "text": "Recipe: research with status active. Query research table. Filter by status = 'active' (or appropriate status value). Use COUNT(*) to count how many researchs are active. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:status_failed", "doc_type": "query_recipe", "text": "Recipe: research with status failed. Query research table. Filter by status = 'failed' (or appropriate status value). Use COUNT(*) to count how many researchs are failed. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:status_pending", "doc_type": "query_recipe", "text": "Recipe: research with status pending. Query research table. Filter by status = 'pending' (or appropriate status value). Use COUNT(*) to count how many researchs are pending. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "pending", "running", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:status_success", "doc_type": "query_recipe", "text": "Recipe: research with status success. Query research table. Filter by status = 'success' (or appropriate status value). Use COUNT(*) to count how many researchs are success. Return matching records or count.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_status", "doc_type": "query_recipe", "text": "Recipe: how many researchs with specific status. Query research table. Use COUNT(*) with filter WHERE status = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "Research", "table": "research", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "count", "failed", "how many", "number", "running", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.research.Research.methodology", "doc_type": "schema_column", "text": "Column: Research.methodology (table research) — text Used to track or store data field.", "metadata": {"model": "Research", "table": "research", "column": "methodology", "type": "TEXT", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["methodology"]}}
{"id": "schema_column:models.research.Research.methodology_structured", "doc_type": "schema_column", "text": "Column: Research.methodology_structured (table research) — JSON object Used to track or store data field.", "metadata": {"model": "Research", "table": "research", "column": "methodology_structured", "type": "JSON", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["methodology", "structured"]}}
{"id": "schema_column:models.research.Research.insights", "doc_type": "schema_column", "text": "Column: Research.insights (table research) — text Used to track or store data field.", "metadata": {"model": "Research", "table": "research", "column": "insights", "type": "TEXT", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["insights"]}}
{"id": "schema_column:models.research.Research.session_id", "doc_type": "schema_column", "text": "Column: Research.session_id (table research) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "Research", "table": "research", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:research.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from research. Filter by research.session_id to find specific records.. Return Research.session_id", "metadata": {"model": "Research", "table": "research", "column": "session_id", "join_hints": ["research.id -> experiments.research_id", "research.id -> research_questions.research_id", "research.id -> notes.research_id"], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.research.Research.created_at", "doc_type": "schema_column", "text": "Column: Research.created_at (table research) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "Research", "table": "research", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: research created at in specific year or date range. Query research table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "Research", "table": "research", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: research created at in the last week. Query research table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Research", "table": "research", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.research.Research.updated_at", "doc_type": "schema_column", "text": "Column: Research.updated_at (table research) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "Research", "table": "research", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: research updated at recently. Query research table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "Research", "table": "research", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: research updated at in the last week. Query research table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Research", "table": "research", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:research_linked_to_experiments", "doc_type": "query_recipe", "text": "Recipe: research linked to experiment. Join research to experiments on research.id -> experiments.research_id. Filter by research fields to find specific records. Return related experiments records or experiments fields.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["research.id -> experiments.research_id"], "keywords": ["connection", "experiment", "experiments", "linked", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_for_research", "doc_type": "query_recipe", "text": "Recipe: experiment for research. Join experiments to research on research.id -> experiments.research_id. Filter by research fields to find specific research. Return related experiments records.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["research.id -> experiments.research_id"], "keywords": ["associated", "belongs", "experiment", "for", "research"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:research_linked_to_research_questions", "doc_type": "query_recipe", "text": "Recipe: research linked to researchquestion. Join research to research_questions on research.id -> research_questions.research_id. Filter by research fields to find specific records. Return related research_questions records or research_questions fields.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["research.id -> research_questions.research_id"], "keywords": ["connection", "linked", "questions", "related", "relationship", "research", "researchquestion"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:research_questions_for_research", "doc_type": "query_recipe", "text": "Recipe: researchquestion for research. Join research_questions to research on research.id -> research_questions.research_id. Filter by research fields to find specific research. Return related research_questions records.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": null, "join_hints": ["research.id -> research_questions.research_id"], "keywords": ["associated", "belongs", "for", "research", "researchquestion"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:research_linked_to_notes", "doc_type": "query_recipe", "text": "Recipe: research linked to note. Join research to notes on research.id -> notes.research_id. Filter by research fields to find specific records. Return related notes records or notes fields.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["research.id -> notes.research_id"], "keywords": ["connection", "entries", "linked", "note", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:notes_for_research", "doc_type": "query_recipe", "text": "Recipe: notes for research projects. Join research to notes on research.id = notes.research_id. Filter by research.name or research.id if specific research project requested. Return notes.content, notes.created_at, and research.name. Order by notes.created_at DESC to show most recent notes first.", "metadata": {"model": "Note", "table": "notes", "column": "research_id", "join_hints": ["notes.research_id -> research.id", "research.name (optional filter)"], "keywords": ["notes", "for", "research", "related", "linked", "associated"], "semantics": "Relationship query: notes for research", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:list_all_research_names", "doc_type": "query_recipe", "text": "Recipe: list all research names. Query research table. Use SELECT name FROM research. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "Research", "table": "research", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:research_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: research names and descriptions. Query research table. Use SELECT name, description FROM research. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_research", "doc_type": "query_recipe", "text": "Recipe: all researchs. Query research table. Use SELECT * FROM research or SELECT specific columns. Optionally filter by conditions if specified. Return all records from research.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "research"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.research.ResearchQuestion", "doc_type": "schema_model", "text": "Model: ResearchQuestion (table research_questions) — Structured research question linked to research artifacts. This model stores research goals, questions, and related information. Key columns: research id (identifier), status (current status or state), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: research goals and questions, temporal queries and filtering Example queries: 'researchquestion goals', 'researchquestion questions', 'researchquestion status' Relationships: related to research via research", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "source_file": "backend/models/research.py"}}
{"id": "schema_column:models.research.ResearchQuestion.id", "doc_type": "schema_column", "text": "Column: ResearchQuestion.id (table research_questions) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["id"]}}
{"id": "query_recipe:research_questions.id", "doc_type": "query_recipe", "text": "Recipe: access id from research_questions. Filter by research_questions.id to find specific records.. Return ResearchQuestion.id", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "id", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.research.ResearchQuestion.research_id", "doc_type": "schema_column", "text": "Column: ResearchQuestion.research_id (table research_questions) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "research_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["id", "research"]}}
{"id": "query_recipe:research_questions.research_id", "doc_type": "query_recipe", "text": "Recipe: access research_id from research_questions. Filter by research_questions.research_id to find specific records.. Return ResearchQuestion.research_id", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "research_id", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["id", "research"], "semantics": null}}
{"id": "schema_column:models.research.ResearchQuestion.prompt", "doc_type": "schema_column", "text": "Column: ResearchQuestion.prompt (table research_questions) — text Used to track or store data field. Required field.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "prompt", "type": "TEXT", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["prompt"]}}
{"id": "schema_column:models.research.ResearchQuestion.details", "doc_type": "schema_column", "text": "Column: ResearchQuestion.details (table research_questions) — text Used to track or store data field.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "details", "type": "TEXT", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["details"]}}
{"id": "schema_column:models.research.ResearchQuestion.answer", "doc_type": "schema_column", "text": "Column: ResearchQuestion.answer (table research_questions) — text Used to track or store data field.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "answer", "type": "TEXT", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["answer"]}}
{"id": "schema_column:models.research.ResearchQuestion.status", "doc_type": "schema_column", "text": "Column: ResearchQuestion.status (table research_questions) — varchar Used to track or store current status or state. Required field. Default: open. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE status = 'status_value' for filtering, COUNT(*) WHERE status = 'status' for counting by status.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"]}}
{"id": "query_recipe:status_running", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status running. Query research_questions table. Filter by status = 'running' (or appropriate status value). Use COUNT(*) to count how many researchquestions are running. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:status_completed", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status completed. Query research_questions table. Filter by status = 'completed' (or appropriate status value). Use COUNT(*) to count how many researchquestions are completed. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:status_active", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status active. Query research_questions table. Filter by status = 'active' (or appropriate status value). Use COUNT(*) to count how many researchquestions are active. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:status_failed", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status failed. Query research_questions table. Filter by status = 'failed' (or appropriate status value). Use COUNT(*) to count how many researchquestions are failed. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:status_pending", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status pending. Query research_questions table. Filter by status = 'pending' (or appropriate status value). Use COUNT(*) to count how many researchquestions are pending. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "pending", "running", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:status_success", "doc_type": "query_recipe", "text": "Recipe: researchquestion with status success. Query research_questions table. Filter by status = 'success' (or appropriate status value). Use COUNT(*) to count how many researchquestions are success. Return matching records or count.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_status", "doc_type": "query_recipe", "text": "Recipe: how many researchquestions with specific status. Query research_questions table. Use COUNT(*) with filter WHERE status = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "count", "failed", "how many", "number", "running", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.research.ResearchQuestion.priority", "doc_type": "schema_column", "text": "Column: ResearchQuestion.priority (table research_questions) — integer Used to track or store data field. Default: 0. Common query patterns: MAX(priority) or MIN(priority) for min/max, WHERE priority > value for numeric filtering.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "priority", "type": "INTEGER", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["priority"]}}
{"id": "query_recipe:maximum_priority", "doc_type": "query_recipe", "text": "Recipe: maximum or highest priority. Query research_questions table. Use MAX(priority) to find maximum value. Or use ORDER BY priority DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "priority", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "priority", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_priority", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest priority. Query research_questions table. Use MIN(priority) to find minimum value. Or use ORDER BY priority ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "priority", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "priority", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.research.ResearchQuestion.tags", "doc_type": "schema_column", "text": "Column: ResearchQuestion.tags (table research_questions) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "tags", "type": "JSON", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["tags"]}}
{"id": "schema_column:models.research.ResearchQuestion.related_experiment_ids", "doc_type": "schema_column", "text": "Column: ResearchQuestion.related_experiment_ids (table research_questions) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_experiment_ids", "type": "JSON", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["associated", "connection", "connections", "experiment", "ids", "link", "linked", "links", "related"]}}
{"id": "query_recipe:research_questions.related_experiment_ids", "doc_type": "query_recipe", "text": "Recipe: access related_experiment_ids from research_questions. Filter by research_questions.related_experiment_ids to find specific records.. Return ResearchQuestion.related_experiment_ids", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_experiment_ids", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["associated", "connection", "connections", "experiment", "ids", "link", "linked", "links", "related"], "semantics": null}}
{"id": "schema_column:models.research.ResearchQuestion.related_simulation_ids", "doc_type": "schema_column", "text": "Column: ResearchQuestion.related_simulation_ids (table research_questions) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_simulation_ids", "type": "JSON", "nullable": false, "source_file": "backend/models/research.py", "keywords": ["associated", "connection", "connections", "ids", "link", "linked", "links", "related", "simulation"]}}
{"id": "query_recipe:research_questions.related_simulation_ids", "doc_type": "query_recipe", "text": "Recipe: access related_simulation_ids from research_questions. Filter by research_questions.related_simulation_ids to find specific records.. Return ResearchQuestion.related_simulation_ids", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_simulation_ids", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["associated", "connection", "connections", "ids", "link", "linked", "links", "related", "simulation"], "semantics": null}}
{"id": "schema_column:models.research.ResearchQuestion.created_at", "doc_type": "schema_column", "text": "Column: ResearchQuestion.created_at (table research_questions) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: researchquestion created at in specific year or date range. Query research_questions table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: researchquestion created at in the last week. Query research_questions table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.research.ResearchQuestion.updated_at", "doc_type": "schema_column", "text": "Column: ResearchQuestion.updated_at (table research_questions) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/research.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: researchquestion updated at recently. Query research_questions table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: researchquestion updated at in the last week. Query research_questions table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:research_questions_linked_to_research", "doc_type": "query_recipe", "text": "Recipe: researchquestion linked to research. Join research_questions to research on research_questions.research_id -> research.id. Filter by research_questions fields to find specific records. Return related research records or research fields.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": null, "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["connection", "linked", "related", "relationship", "research"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:research_for_research_questions", "doc_type": "query_recipe", "text": "Recipe: research for researchquestion. Join research to research_questions on research_questions.research_id -> research.id. Filter by research_questions fields to find specific researchquestion. Return related research records.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["associated", "belongs", "for", "research", "researchquestion"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_research_questions", "doc_type": "query_recipe", "text": "Recipe: all researchquestions. Query research_questions table. Use SELECT * FROM research_questions or SELECT specific columns. Optionally filter by conditions if specified. Return all records from research_questions.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "researchquestion"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.research_flow_session.ResearchFlowSession", "doc_type": "schema_model", "text": "Model: ResearchFlowSession (table research_flow_sessions) — Persistent record of an interactive research form flow. This model stores research goals, questions, and related information. Key columns: session id (identifier), state (current status or state), state metadata (current status or state), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: research goals and questions, temporal queries and filtering Example queries: 'researchflowsession goals', 'researchflowsession questions', 'researchflowsession status'", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "source_file": "backend/models/research_flow_session.py"}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.id", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.id (table research_flow_sessions) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["id"]}}
{"id": "query_recipe:research_flow_sessions.id", "doc_type": "query_recipe", "text": "Recipe: access id from research_flow_sessions. Filter by research_flow_sessions.id to find specific records.. Return ResearchFlowSession.id", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.session_id", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.session_id (table research_flow_sessions) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:research_flow_sessions.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from research_flow_sessions. Filter by research_flow_sessions.session_id to find specific records.. Return ResearchFlowSession.session_id", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.state", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.state (table research_flow_sessions) — varchar Used to track or store current status or state. Required field. Default: seed. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE state = 'status_value' for filtering, COUNT(*) WHERE state = 'status' for counting by status.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["state"]}}
{"id": "query_recipe:state_running", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status running. Query research_flow_sessions table. Filter by state = 'running' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are running. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["condition", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:state_completed", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status completed. Query research_flow_sessions table. Filter by state = 'completed' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are completed. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["completed", "condition", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:state_active", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status active. Query research_flow_sessions table. Filter by state = 'active' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are active. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["active", "condition", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:state_failed", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status failed. Query research_flow_sessions table. Filter by state = 'failed' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are failed. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["condition", "failed", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:state_pending", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status pending. Query research_flow_sessions table. Filter by state = 'pending' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are pending. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["condition", "pending", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:state_success", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status success. Query research_flow_sessions table. Filter by state = 'success' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are success. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["condition", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_state", "doc_type": "query_recipe", "text": "Recipe: how many researchflowsessions with specific status. Query research_flow_sessions table. Use COUNT(*) with filter WHERE state = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state", "join_hints": [], "keywords": ["count", "how many", "number", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.form_data", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.form_data (table research_flow_sessions) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "form_data", "type": "JSON", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["data", "form"]}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.state_metadata", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.state_metadata (table research_flow_sessions) — JSON object Used to track or store current status or state. Default: function dict. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE state_metadata = 'status_value' for filtering, COUNT(*) WHERE state_metadata = 'status' for counting by status.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "type": "JSON", "nullable": true, "source_file": "backend/models/research_flow_session.py", "keywords": ["metadata", "state"]}}
{"id": "query_recipe:state_metadata_running", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status running. Query research_flow_sessions table. Filter by state_metadata = 'running' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are running. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["condition", "metadata", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:state_metadata_completed", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status completed. Query research_flow_sessions table. Filter by state_metadata = 'completed' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are completed. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["completed", "condition", "metadata", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:state_metadata_active", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status active. Query research_flow_sessions table. Filter by state_metadata = 'active' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are active. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["active", "condition", "metadata", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:state_metadata_failed", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status failed. Query research_flow_sessions table. Filter by state_metadata = 'failed' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are failed. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["condition", "failed", "metadata", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:state_metadata_pending", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status pending. Query research_flow_sessions table. Filter by state_metadata = 'pending' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are pending. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["condition", "metadata", "pending", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:state_metadata_success", "doc_type": "query_recipe", "text": "Recipe: researchflowsession with status success. Query research_flow_sessions table. Filter by state_metadata = 'success' (or appropriate status value). Use COUNT(*) to count how many researchflowsessions are success. Return matching records or count.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["condition", "metadata", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_state_metadata", "doc_type": "query_recipe", "text": "Recipe: how many researchflowsessions with specific status. Query research_flow_sessions table. Use COUNT(*) with filter WHERE state_metadata = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "state_metadata", "join_hints": [], "keywords": ["count", "how many", "metadata", "number", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.history", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.history (table research_flow_sessions) — JSON object Used to track or store data field. Default: function list.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "history", "type": "JSON", "nullable": true, "source_file": "backend/models/research_flow_session.py", "keywords": ["history"]}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.summary", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.summary (table research_flow_sessions) — text Used to track or store data field.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "summary", "type": "TEXT", "nullable": true, "source_file": "backend/models/research_flow_session.py", "keywords": ["summary"]}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.created_at", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.created_at (table research_flow_sessions) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: researchflowsession created at in specific year or date range. Query research_flow_sessions table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: researchflowsession created at in the last week. Query research_flow_sessions table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.updated_at", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.updated_at (table research_flow_sessions) — datetime Used to track or store timestamp when record was last updated. Required field. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "updated_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/research_flow_session.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: researchflowsession updated at recently. Query research_flow_sessions table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: researchflowsession updated at in the last week. Query research_flow_sessions table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.research_flow_session.ResearchFlowSession.completed_at", "doc_type": "schema_column", "text": "Column: ResearchFlowSession.completed_at (table research_flow_sessions) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(completed_at) = year for year filtering, WHERE completed_at BETWEEN start AND end for date ranges.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "completed_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/research_flow_session.py", "keywords": ["at", "complete", "completed", "done", "ended", "finished"]}}
{"id": "query_recipe:completed_at_last_week", "doc_type": "query_recipe", "text": "Recipe: researchflowsession completed at in the last week. Query research_flow_sessions table. Filter by completed_at >= NOW() - INTERVAL '7' DAYS or WHERE completed_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": "completed_at", "join_hints": [], "keywords": ["at", "complete", "completed", "done", "ended", "finished", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_research_flow_sessions", "doc_type": "query_recipe", "text": "Recipe: all researchflowsessions. Query research_flow_sessions table. Use SELECT * FROM research_flow_sessions or SELECT specific columns. Optionally filter by conditions if specified. Return all records from research_flow_sessions.", "metadata": {"model": "ResearchFlowSession", "table": "research_flow_sessions", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "researchflowsession"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.local_llm_probe.LocalLLMDecisionRun", "doc_type": "schema_model", "text": "Model: LocalLLMDecisionRun (table local_llm_decision_runs) — Persisted record for a quick-decision probe run. Key columns: status (current status or state), success count (number of success), failure count (number of failure), correct count (number of correct), incorrect count (number of incorrect), created at (timestamp when record was created) Commonly used for: temporal queries and filtering Example queries: 'localllmdecisionrun status'", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "source_file": "backend/models/local_llm_probe.py"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.id", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.id (table local_llm_decision_runs) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["id"]}}
{"id": "query_recipe:local_llm_decision_runs.id", "doc_type": "query_recipe", "text": "Recipe: access id from local_llm_decision_runs. Filter by local_llm_decision_runs.id to find specific records.. Return LocalLLMDecisionRun.id", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.status", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.status (table local_llm_decision_runs) — varchar Used to track or store current status or state. Required field. Default: completed. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE status = 'status_value' for filtering, COUNT(*) WHERE status = 'status' for counting by status.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"]}}
{"id": "query_recipe:status_running", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status running. Query local_llm_decision_runs table. Filter by status = 'running' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are running. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:status_completed", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status completed. Query local_llm_decision_runs table. Filter by status = 'completed' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are completed. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:status_active", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status active. Query local_llm_decision_runs table. Filter by status = 'active' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are active. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:status_failed", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status failed. Query local_llm_decision_runs table. Filter by status = 'failed' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are failed. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:status_pending", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status pending. Query local_llm_decision_runs table. Filter by status = 'pending' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are pending. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "pending", "running", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:status_success", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun with status success. Query local_llm_decision_runs table. Filter by status = 'success' (or appropriate status value). Use COUNT(*) to count how many localllmdecisionruns are success. Return matching records or count.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_status", "doc_type": "query_recipe", "text": "Recipe: how many localllmdecisionruns with specific status. Query local_llm_decision_runs table. Use COUNT(*) with filter WHERE status = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "count", "failed", "how many", "number", "running", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.error", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.error (table local_llm_decision_runs) — text Used to track or store data field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "error", "type": "TEXT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["error"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.base_url", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.base_url (table local_llm_decision_runs) — varchar Used to track or store data field. Required field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "base_url", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["base", "url"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.model", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.model (table local_llm_decision_runs) — varchar Used to track or store data field. Required field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "model", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["model"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.num_requests", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.num_requests (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Common query patterns: MAX(num_requests) or MIN(num_requests) for min/max, WHERE num_requests > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "num_requests", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["num", "requests"]}}
{"id": "query_recipe:maximum_num_requests", "doc_type": "query_recipe", "text": "Recipe: maximum or highest num requests. Query local_llm_decision_runs table. Use MAX(num_requests) to find maximum value. Or use ORDER BY num_requests DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "num_requests", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "num", "requests", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_num_requests", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest num requests. Query local_llm_decision_runs table. Use MIN(num_requests) to find minimum value. Or use ORDER BY num_requests ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "num_requests", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "num", "requests", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.concurrency", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.concurrency (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Common query patterns: MAX(concurrency) or MIN(concurrency) for min/max, WHERE concurrency > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "concurrency", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["concurrency"]}}
{"id": "query_recipe:maximum_concurrency", "doc_type": "query_recipe", "text": "Recipe: maximum or highest concurrency. Query local_llm_decision_runs table. Use MAX(concurrency) to find maximum value. Or use ORDER BY concurrency DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "concurrency", "join_hints": [], "keywords": ["best", "concurrency", "highest", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_concurrency", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest concurrency. Query local_llm_decision_runs table. Use MIN(concurrency) to find minimum value. Or use ORDER BY concurrency ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "concurrency", "join_hints": [], "keywords": ["concurrency", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.question_types", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.question_types (table local_llm_decision_runs) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "question_types", "type": "JSON", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["question", "types"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.max_tokens", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.max_tokens (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Common query patterns: MAX(max_tokens) or MIN(max_tokens) for min/max, WHERE max_tokens > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "max_tokens", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["max", "tokens"]}}
{"id": "query_recipe:maximum_max_tokens", "doc_type": "query_recipe", "text": "Recipe: maximum or highest max tokens. Query local_llm_decision_runs table. Use MAX(max_tokens) to find maximum value. Or use ORDER BY max_tokens DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "max_tokens", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "tokens", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_max_tokens", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest max tokens. Query local_llm_decision_runs table. Use MIN(max_tokens) to find minimum value. Or use ORDER BY max_tokens ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "max_tokens", "join_hints": [], "keywords": ["least", "lowest", "max", "min", "minimum", "smallest", "tokens"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.temperature", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.temperature (table local_llm_decision_runs) — numeric Used to track or store data field. Required field. Common query patterns: MAX(temperature) or MIN(temperature) for min/max, WHERE temperature > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "temperature", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["temperature"]}}
{"id": "query_recipe:maximum_temperature", "doc_type": "query_recipe", "text": "Recipe: maximum or highest temperature. Query local_llm_decision_runs table. Use MAX(temperature) to find maximum value. Or use ORDER BY temperature DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "temperature", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "temperature", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_temperature", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest temperature. Query local_llm_decision_runs table. Use MIN(temperature) to find minimum value. Or use ORDER BY temperature ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "temperature", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "temperature"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.timeout", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.timeout (table local_llm_decision_runs) — numeric timestamp or duration Used to track or store timestamp or duration. Required field. Common query patterns: MAX(timeout) or MIN(timeout) for min/max, WHERE timeout > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "timeout", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["duration", "elapsed", "runtime", "time", "timeout"]}}
{"id": "query_recipe:maximum_timeout", "doc_type": "query_recipe", "text": "Recipe: maximum or highest timeout. Query local_llm_decision_runs table. Use MAX(timeout) to find maximum value. Or use ORDER BY timeout DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "timeout", "join_hints": [], "keywords": ["best", "duration", "elapsed", "highest", "max", "maximum", "most", "runtime", "time", "timeout", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_timeout", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest timeout. Query local_llm_decision_runs table. Use MIN(timeout) to find minimum value. Or use ORDER BY timeout ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "timeout", "join_hints": [], "keywords": ["duration", "elapsed", "least", "lowest", "min", "minimum", "runtime", "smallest", "time", "timeout"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.retries", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.retries (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Common query patterns: MAX(retries) or MIN(retries) for min/max, WHERE retries > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "retries", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["retries"]}}
{"id": "query_recipe:maximum_retries", "doc_type": "query_recipe", "text": "Recipe: maximum or highest retries. Query local_llm_decision_runs table. Use MAX(retries) to find maximum value. Or use ORDER BY retries DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "retries", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "retries", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_retries", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest retries. Query local_llm_decision_runs table. Use MIN(retries) to find minimum value. Or use ORDER BY retries ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "retries", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "retries", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.seed", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.seed (table local_llm_decision_runs) — integer Used to track or store data field. Common query patterns: MAX(seed) or MIN(seed) for min/max, WHERE seed > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "seed", "type": "INTEGER", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["seed"]}}
{"id": "query_recipe:maximum_seed", "doc_type": "query_recipe", "text": "Recipe: maximum or highest seed. Query local_llm_decision_runs table. Use MAX(seed) to find maximum value. Or use ORDER BY seed DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "seed", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "seed", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_seed", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest seed. Query local_llm_decision_runs table. Use MIN(seed) to find minimum value. Or use ORDER BY seed ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "seed", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "seed", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.sample_size", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.sample_size (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Default: 5. Common query patterns: MAX(sample_size) or MIN(sample_size) for min/max, WHERE sample_size > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "sample_size", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["sample", "size"]}}
{"id": "query_recipe:maximum_sample_size", "doc_type": "query_recipe", "text": "Recipe: maximum or highest sample size. Query local_llm_decision_runs table. Use MAX(sample_size) to find maximum value. Or use ORDER BY sample_size DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "sample_size", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "sample", "size", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_sample_size", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest sample size. Query local_llm_decision_runs table. Use MIN(sample_size) to find minimum value. Or use ORDER BY sample_size ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "sample_size", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "sample", "size", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.total_requests", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.total_requests (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Default: 0. Common query patterns: MAX(total_requests) or MIN(total_requests) for min/max, WHERE total_requests > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "total_requests", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["requests", "total"]}}
{"id": "query_recipe:maximum_total_requests", "doc_type": "query_recipe", "text": "Recipe: maximum or highest total requests. Query local_llm_decision_runs table. Use MAX(total_requests) to find maximum value. Or use ORDER BY total_requests DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "total_requests", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "requests", "top", "total"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_total_requests", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest total requests. Query local_llm_decision_runs table. Use MIN(total_requests) to find minimum value. Or use ORDER BY total_requests ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "total_requests", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "requests", "smallest", "total"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.success_count", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.success_count (table local_llm_decision_runs) — integer counter of success Used to track or store number of success. Required field. Default: 0. Common query patterns: COUNT(*) or SUM(success_count) for aggregation, WHERE success_count > value for filtering. Related columns: failure_count, correct_count, incorrect_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "success_count", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"]}}
{"id": "query_recipe:local_llm_decision_runs.success_count", "doc_type": "query_recipe", "text": "Recipe: access success_count from local_llm_decision_runs. Return LocalLLMDecisionRun.success_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "success_count", "join_hints": [], "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"], "semantics": null}}
{"id": "query_recipe:how_many_success_count", "doc_type": "query_recipe", "text": "Recipe: how many success. Query local_llm_decision_runs table. Use COUNT(*) or SUM(success_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "success_count", "join_hints": [], "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.failure_count", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.failure_count (table local_llm_decision_runs) — integer counter of failure Used to track or store number of failure. Required field. Default: 0. Common query patterns: COUNT(*) or SUM(failure_count) for aggregation, WHERE failure_count > value for filtering. Related columns: success_count, correct_count, incorrect_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "failure_count", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"]}}
{"id": "query_recipe:local_llm_decision_runs.failure_count", "doc_type": "query_recipe", "text": "Recipe: access failure_count from local_llm_decision_runs. Return LocalLLMDecisionRun.failure_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "failure_count", "join_hints": [], "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"], "semantics": null}}
{"id": "query_recipe:how_many_failure_count", "doc_type": "query_recipe", "text": "Recipe: how many failure. Query local_llm_decision_runs table. Use COUNT(*) or SUM(failure_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "failure_count", "join_hints": [], "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.correct_count", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.correct_count (table local_llm_decision_runs) — integer counter of correct Used to track or store number of correct. Required field. Default: 0. Common query patterns: COUNT(*) or SUM(correct_count) for aggregation, WHERE correct_count > value for filtering. Related columns: success_count, failure_count, incorrect_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "correct_count", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["correct", "count", "how many", "how many times", "number", "quantity", "total"]}}
{"id": "query_recipe:local_llm_decision_runs.correct_count", "doc_type": "query_recipe", "text": "Recipe: access correct_count from local_llm_decision_runs. Return LocalLLMDecisionRun.correct_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "correct_count", "join_hints": [], "keywords": ["correct", "count", "how many", "how many times", "number", "quantity", "total"], "semantics": null}}
{"id": "query_recipe:how_many_correct_count", "doc_type": "query_recipe", "text": "Recipe: how many correct. Query local_llm_decision_runs table. Use COUNT(*) or SUM(correct_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "correct_count", "join_hints": [], "keywords": ["correct", "count", "how many", "how many times", "number", "quantity", "total"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.incorrect_count", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.incorrect_count (table local_llm_decision_runs) — integer counter of incorrect Used to track or store number of incorrect. Required field. Default: 0. Common query patterns: COUNT(*) or SUM(incorrect_count) for aggregation, WHERE incorrect_count > value for filtering. Related columns: success_count, failure_count, correct_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "incorrect_count", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["count", "how many", "how many times", "incorrect", "number", "quantity", "total"]}}
{"id": "query_recipe:local_llm_decision_runs.incorrect_count", "doc_type": "query_recipe", "text": "Recipe: access incorrect_count from local_llm_decision_runs. Return LocalLLMDecisionRun.incorrect_count", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "incorrect_count", "join_hints": [], "keywords": ["count", "how many", "how many times", "incorrect", "number", "quantity", "total"], "semantics": null}}
{"id": "query_recipe:how_many_incorrect_count", "doc_type": "query_recipe", "text": "Recipe: how many incorrect. Query local_llm_decision_runs table. Use COUNT(*) or SUM(incorrect_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "incorrect_count", "join_hints": [], "keywords": ["count", "how many", "how many times", "incorrect", "number", "quantity", "total"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.accuracy", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.accuracy (table local_llm_decision_runs) — numeric Used to track or store data field. Common query patterns: MAX(accuracy) or MIN(accuracy) for min/max, WHERE accuracy > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "accuracy", "type": "FLOAT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["accuracy"]}}
{"id": "query_recipe:maximum_accuracy", "doc_type": "query_recipe", "text": "Recipe: maximum or highest accuracy. Query local_llm_decision_runs table. Use MAX(accuracy) to find maximum value. Or use ORDER BY accuracy DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "accuracy", "join_hints": [], "keywords": ["accuracy", "best", "highest", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_accuracy", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest accuracy. Query local_llm_decision_runs table. Use MIN(accuracy) to find minimum value. Or use ORDER BY accuracy ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "accuracy", "join_hints": [], "keywords": ["accuracy", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.wall_time_seconds", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.wall_time_seconds (table local_llm_decision_runs) — numeric timestamp or duration Used to track or store timestamp or duration. Required field. Default: 0.0. Common query patterns: MAX(wall_time_seconds) or MIN(wall_time_seconds) for min/max, WHERE wall_time_seconds > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "wall_time_seconds", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["duration", "elapsed", "runtime", "seconds", "time", "wall"]}}
{"id": "query_recipe:maximum_wall_time_seconds", "doc_type": "query_recipe", "text": "Recipe: maximum or highest wall time seconds. Query local_llm_decision_runs table. Use MAX(wall_time_seconds) to find maximum value. Or use ORDER BY wall_time_seconds DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "wall_time_seconds", "join_hints": [], "keywords": ["best", "duration", "elapsed", "highest", "max", "maximum", "most", "runtime", "seconds", "time", "top", "wall"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_wall_time_seconds", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest wall time seconds. Query local_llm_decision_runs table. Use MIN(wall_time_seconds) to find minimum value. Or use ORDER BY wall_time_seconds ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "wall_time_seconds", "join_hints": [], "keywords": ["duration", "elapsed", "least", "lowest", "min", "minimum", "runtime", "seconds", "smallest", "time", "wall"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.throughput_total", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.throughput_total (table local_llm_decision_runs) — numeric Used to track or store data field. Required field. Default: 0.0. Common query patterns: MAX(throughput_total) or MIN(throughput_total) for min/max, WHERE throughput_total > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_total", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["throughput", "total"]}}
{"id": "query_recipe:maximum_throughput_total", "doc_type": "query_recipe", "text": "Recipe: maximum or highest throughput total. Query local_llm_decision_runs table. Use MAX(throughput_total) to find maximum value. Or use ORDER BY throughput_total DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_total", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "throughput", "top", "total"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_throughput_total", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest throughput total. Query local_llm_decision_runs table. Use MIN(throughput_total) to find minimum value. Or use ORDER BY throughput_total ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_total", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "throughput", "total"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.throughput_success", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.throughput_success (table local_llm_decision_runs) — numeric Used to track or store number of successful operations. Required field. Default: 0.0. Common query patterns: MAX(throughput_success) or MIN(throughput_success) for min/max, WHERE throughput_success > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_success", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["succeeded", "success", "throughput", "win", "wins"]}}
{"id": "query_recipe:maximum_throughput_success", "doc_type": "query_recipe", "text": "Recipe: maximum or highest throughput success. Query local_llm_decision_runs table. Use MAX(throughput_success) to find maximum value. Or use ORDER BY throughput_success DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_success", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "succeeded", "success", "throughput", "top", "win", "wins"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_throughput_success", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest throughput success. Query local_llm_decision_runs table. Use MIN(throughput_success) to find minimum value. Or use ORDER BY throughput_success ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "throughput_success", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "succeeded", "success", "throughput", "win", "wins"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.latency_median_ms", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.latency_median_ms (table local_llm_decision_runs) — numeric Used to track or store data field. Common query patterns: MAX(latency_median_ms) or MIN(latency_median_ms) for min/max, WHERE latency_median_ms > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_median_ms", "type": "FLOAT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["latency", "median", "ms"]}}
{"id": "query_recipe:maximum_latency_median_ms", "doc_type": "query_recipe", "text": "Recipe: maximum or highest latency median ms. Query local_llm_decision_runs table. Use MAX(latency_median_ms) to find maximum value. Or use ORDER BY latency_median_ms DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_median_ms", "join_hints": [], "keywords": ["best", "highest", "latency", "max", "maximum", "median", "most", "ms", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_latency_median_ms", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest latency median ms. Query local_llm_decision_runs table. Use MIN(latency_median_ms) to find minimum value. Or use ORDER BY latency_median_ms ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_median_ms", "join_hints": [], "keywords": ["latency", "least", "lowest", "median", "min", "minimum", "ms", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.latency_mean_ms", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.latency_mean_ms (table local_llm_decision_runs) — numeric Used to track or store data field. Common query patterns: MAX(latency_mean_ms) or MIN(latency_mean_ms) for min/max, WHERE latency_mean_ms > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_mean_ms", "type": "FLOAT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["latency", "mean", "ms"]}}
{"id": "query_recipe:maximum_latency_mean_ms", "doc_type": "query_recipe", "text": "Recipe: maximum or highest latency mean ms. Query local_llm_decision_runs table. Use MAX(latency_mean_ms) to find maximum value. Or use ORDER BY latency_mean_ms DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_mean_ms", "join_hints": [], "keywords": ["best", "highest", "latency", "max", "maximum", "mean", "most", "ms", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_latency_mean_ms", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest latency mean ms. Query local_llm_decision_runs table. Use MIN(latency_mean_ms) to find minimum value. Or use ORDER BY latency_mean_ms ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_mean_ms", "join_hints": [], "keywords": ["latency", "least", "lowest", "mean", "min", "minimum", "ms", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.latency_p95_ms", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.latency_p95_ms (table local_llm_decision_runs) — numeric Used to track or store data field. Common query patterns: MAX(latency_p95_ms) or MIN(latency_p95_ms) for min/max, WHERE latency_p95_ms > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_p95_ms", "type": "FLOAT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["latency", "ms", "p"]}}
{"id": "query_recipe:maximum_latency_p95_ms", "doc_type": "query_recipe", "text": "Recipe: maximum or highest latency p95 ms. Query local_llm_decision_runs table. Use MAX(latency_p95_ms) to find maximum value. Or use ORDER BY latency_p95_ms DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_p95_ms", "join_hints": [], "keywords": ["best", "highest", "latency", "max", "maximum", "most", "ms", "p", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_latency_p95_ms", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest latency p95 ms. Query local_llm_decision_runs table. Use MIN(latency_p95_ms) to find minimum value. Or use ORDER BY latency_p95_ms ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "latency_p95_ms", "join_hints": [], "keywords": ["latency", "least", "lowest", "min", "minimum", "ms", "p", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.tokens_total", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.tokens_total (table local_llm_decision_runs) — integer Used to track or store data field. Required field. Default: 0. Common query patterns: MAX(tokens_total) or MIN(tokens_total) for min/max, WHERE tokens_total > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_total", "type": "INTEGER", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["tokens", "total"]}}
{"id": "query_recipe:maximum_tokens_total", "doc_type": "query_recipe", "text": "Recipe: maximum or highest tokens total. Query local_llm_decision_runs table. Use MAX(tokens_total) to find maximum value. Or use ORDER BY tokens_total DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_total", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "tokens", "top", "total"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_tokens_total", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest tokens total. Query local_llm_decision_runs table. Use MIN(tokens_total) to find minimum value. Or use ORDER BY tokens_total ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_total", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "tokens", "total"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.tokens_per_sec", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.tokens_per_sec (table local_llm_decision_runs) — numeric Used to track or store data field. Required field. Default: 0.0. Common query patterns: MAX(tokens_per_sec) or MIN(tokens_per_sec) for min/max, WHERE tokens_per_sec > value for numeric filtering.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_per_sec", "type": "FLOAT", "nullable": false, "source_file": "backend/models/local_llm_probe.py", "keywords": ["per", "sec", "tokens"]}}
{"id": "query_recipe:maximum_tokens_per_sec", "doc_type": "query_recipe", "text": "Recipe: maximum or highest tokens per sec. Query local_llm_decision_runs table. Use MAX(tokens_per_sec) to find maximum value. Or use ORDER BY tokens_per_sec DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_per_sec", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "per", "sec", "tokens", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_tokens_per_sec", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest tokens per sec. Query local_llm_decision_runs table. Use MIN(tokens_per_sec) to find minimum value. Or use ORDER BY tokens_per_sec ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "tokens_per_sec", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "per", "sec", "smallest", "tokens"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.avg_completion_tokens", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.avg_completion_tokens (table local_llm_decision_runs) — numeric Used to track or store data field. Common query patterns: AVG(avg_completion_tokens) for average calculation.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "avg_completion_tokens", "type": "FLOAT", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["avg", "completion", "tokens"]}}
{"id": "query_recipe:average_avg_completion_tokens", "doc_type": "query_recipe", "text": "Recipe: average avg completion tokens. Query local_llm_decision_runs table. Use AVG(avg_completion_tokens) to calculate average. Filter by appropriate conditions if specified. Group by relevant fields if needed. Return the average value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "avg_completion_tokens", "join_hints": [], "keywords": ["average", "avg", "completion", "mean", "tokens", "typical"], "semantics": "Aggregation: AVG", "recipe_type": "aggregation"}}
{"id": "query_recipe:maximum_avg_completion_tokens", "doc_type": "query_recipe", "text": "Recipe: maximum or highest avg completion tokens. Query local_llm_decision_runs table. Use MAX(avg_completion_tokens) to find maximum value. Or use ORDER BY avg_completion_tokens DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "avg_completion_tokens", "join_hints": [], "keywords": ["avg", "best", "completion", "highest", "max", "maximum", "most", "tokens", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_avg_completion_tokens", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest avg completion tokens. Query local_llm_decision_runs table. Use MIN(avg_completion_tokens) to find minimum value. Or use ORDER BY avg_completion_tokens ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "avg_completion_tokens", "join_hints": [], "keywords": ["avg", "completion", "least", "lowest", "min", "minimum", "smallest", "tokens"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.categories_snapshot", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.categories_snapshot (table local_llm_decision_runs) — JSON object Used to track or store data field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "categories_snapshot", "type": "JSON", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["categories", "snapshot"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.samples", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.samples (table local_llm_decision_runs) — JSON object Used to track or store data field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "samples", "type": "JSON", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["samples"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.errors", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.errors (table local_llm_decision_runs) — JSON object Used to track or store data field.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "errors", "type": "JSON", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["errors"]}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.created_at", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.created_at (table local_llm_decision_runs) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun created at in specific year or date range. Query local_llm_decision_runs table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun created at in the last week. Query local_llm_decision_runs table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.local_llm_probe.LocalLLMDecisionRun.completed_at", "doc_type": "schema_column", "text": "Column: LocalLLMDecisionRun.completed_at (table local_llm_decision_runs) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(completed_at) = year for year filtering, WHERE completed_at BETWEEN start AND end for date ranges.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "completed_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/local_llm_probe.py", "keywords": ["at", "complete", "completed", "done", "ended", "finished"]}}
{"id": "query_recipe:completed_at_last_week", "doc_type": "query_recipe", "text": "Recipe: localllmdecisionrun completed at in the last week. Query local_llm_decision_runs table. Filter by completed_at >= NOW() - INTERVAL '7' DAYS or WHERE completed_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": "completed_at", "join_hints": [], "keywords": ["at", "complete", "completed", "done", "ended", "finished", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_local_llm_decision_runs", "doc_type": "query_recipe", "text": "Recipe: all localllmdecisionruns. Query local_llm_decision_runs table. Use SELECT * FROM local_llm_decision_runs or SELECT specific columns. Optionally filter by conditions if specified. Return all records from local_llm_decision_runs.", "metadata": {"model": "LocalLLMDecisionRun", "table": "local_llm_decision_runs", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "localllmdecisionrun"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.Simulation", "doc_type": "schema_model", "text": "Model: Simulation (table simulations) — Simulation model - stores metadata about a simulation run. This model tracks simulation executions, status, and results. Key columns: name (name or label for identification), status (current status or state), created at (timestamp when record was created), updated at (timestamp when record was last updated), process id (identifier), experiment id (identifier) Commonly used for: simulation execution tracking, simulation status monitoring, temporal queries and filtering Example queries: 'simulation status', 'simulation information', 'running simulations', 'completed simulations', 'simulation names' Relationships: related to simulationconfig via simulation_config, related to experiment via experiment", "metadata": {"model": "Simulation", "table": "simulations", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.Simulation.id", "doc_type": "schema_column", "text": "Column: Simulation.id (table simulations) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "Simulation", "table": "simulations", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:simulations.id", "doc_type": "query_recipe", "text": "Recipe: access id from simulations. Filter by simulations.id to find specific records.. Return Simulation.id", "metadata": {"model": "Simulation", "table": "simulations", "column": "id", "join_hints": ["simulations.id -> simulation_configs.simulation_id", "simulations.experiment_id -> experiments.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.simulation.Simulation.name", "doc_type": "schema_column", "text": "Column: Simulation.name (table simulations) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "Simulation", "table": "simulations", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:simulations.name", "doc_type": "query_recipe", "text": "Recipe: access name from simulations. Filter by simulations.name to find specific records.. Return Simulation.name", "metadata": {"model": "Simulation", "table": "simulations", "column": "name", "join_hints": ["simulations.id -> simulation_configs.simulation_id", "simulations.experiment_id -> experiments.id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.simulation.Simulation.description", "doc_type": "schema_column", "text": "Column: Simulation.description (table simulations) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "Simulation", "table": "simulations", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.simulation.Simulation.status", "doc_type": "schema_column", "text": "Column: Simulation.status (table simulations) — varchar Used to track or store current status or state. Default: created. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE status = 'status_value' for filtering, COUNT(*) WHERE status = 'status' for counting by status.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"]}}
{"id": "query_recipe:status_running", "doc_type": "query_recipe", "text": "Recipe: simulation with status running. Query simulations table. Filter by status = 'running' (or appropriate status value). Use COUNT(*) to count how many simulations are running. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:status_completed", "doc_type": "query_recipe", "text": "Recipe: simulation with status completed. Query simulations table. Filter by status = 'completed' (or appropriate status value). Use COUNT(*) to count how many simulations are completed. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:status_active", "doc_type": "query_recipe", "text": "Recipe: simulation with status active. Query simulations table. Filter by status = 'active' (or appropriate status value). Use COUNT(*) to count how many simulations are active. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:status_failed", "doc_type": "query_recipe", "text": "Recipe: simulation with status failed. Query simulations table. Filter by status = 'failed' (or appropriate status value). Use COUNT(*) to count how many simulations are failed. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:status_pending", "doc_type": "query_recipe", "text": "Recipe: simulation with status pending. Query simulations table. Filter by status = 'pending' (or appropriate status value). Use COUNT(*) to count how many simulations are pending. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "pending", "running", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:status_success", "doc_type": "query_recipe", "text": "Recipe: simulation with status success. Query simulations table. Filter by status = 'success' (or appropriate status value). Use COUNT(*) to count how many simulations are success. Return matching records or count.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "failed", "running", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_status", "doc_type": "query_recipe", "text": "Recipe: how many simulations with specific status. Query simulations table. Use COUNT(*) with filter WHERE status = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["active", "completed", "condition", "count", "failed", "how many", "number", "running", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.simulation.Simulation.created_at", "doc_type": "schema_column", "text": "Column: Simulation.created_at (table simulations) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "Simulation", "table": "simulations", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: simulation created at in specific year or date range. Query simulations table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "Simulation", "table": "simulations", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulation created at in the last week. Query simulations table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Simulation", "table": "simulations", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.Simulation.updated_at", "doc_type": "schema_column", "text": "Column: Simulation.updated_at (table simulations) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "Simulation", "table": "simulations", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: simulation updated at recently. Query simulations table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "Simulation", "table": "simulations", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulation updated at in the last week. Query simulations table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Simulation", "table": "simulations", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.Simulation.started_at", "doc_type": "schema_column", "text": "Column: Simulation.started_at (table simulations) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(started_at) = year for year filtering, WHERE started_at BETWEEN start AND end for date ranges.", "metadata": {"model": "Simulation", "table": "simulations", "column": "started_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["at", "began", "begin", "initiated", "start", "started"]}}
{"id": "query_recipe:started_at_in_year", "doc_type": "query_recipe", "text": "Recipe: simulation started at in specific year or date range. Query simulations table. Filter by started_at using date functions: WHERE YEAR(started_at) = year or WHERE started_at >= start_date AND started_at <= end_date. Return matching records.", "metadata": {"model": "Simulation", "table": "simulations", "column": "started_at", "join_hints": [], "keywords": ["at", "began", "begin", "created", "date", "in", "initiated", "start", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:started_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulation started at in the last week. Query simulations table. Filter by started_at >= NOW() - INTERVAL '7' DAYS or WHERE started_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Simulation", "table": "simulations", "column": "started_at", "join_hints": [], "keywords": ["at", "began", "begin", "initiated", "last week", "past", "recent", "since", "start", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.Simulation.completed_at", "doc_type": "schema_column", "text": "Column: Simulation.completed_at (table simulations) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(completed_at) = year for year filtering, WHERE completed_at BETWEEN start AND end for date ranges.", "metadata": {"model": "Simulation", "table": "simulations", "column": "completed_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["at", "complete", "completed", "done", "ended", "finished"]}}
{"id": "query_recipe:completed_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulation completed at in the last week. Query simulations table. Filter by completed_at >= NOW() - INTERVAL '7' DAYS or WHERE completed_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Simulation", "table": "simulations", "column": "completed_at", "join_hints": [], "keywords": ["at", "complete", "completed", "done", "ended", "finished", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.Simulation.config", "doc_type": "schema_column", "text": "Column: Simulation.config (table simulations) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "Simulation", "table": "simulations", "column": "config", "type": "JSON", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["config"]}}
{"id": "schema_column:models.simulation.Simulation.total_steps", "doc_type": "schema_column", "text": "Column: Simulation.total_steps (table simulations) — integer Used to track or store data field. Default: 0. Common query patterns: MAX(total_steps) or MIN(total_steps) for min/max, WHERE total_steps > value for numeric filtering.", "metadata": {"model": "Simulation", "table": "simulations", "column": "total_steps", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["steps", "total"]}}
{"id": "query_recipe:maximum_total_steps", "doc_type": "query_recipe", "text": "Recipe: maximum or highest total steps. Query simulations table. Use MAX(total_steps) to find maximum value. Or use ORDER BY total_steps DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "total_steps", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "steps", "top", "total"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_total_steps", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest total steps. Query simulations table. Use MIN(total_steps) to find minimum value. Or use ORDER BY total_steps ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "total_steps", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "steps", "total"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.Simulation.final_population", "doc_type": "schema_column", "text": "Column: Simulation.final_population (table simulations) — integer Used to track or store data field. Common query patterns: MAX(final_population) or MIN(final_population) for min/max, WHERE final_population > value for numeric filtering.", "metadata": {"model": "Simulation", "table": "simulations", "column": "final_population", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["final", "population"]}}
{"id": "query_recipe:maximum_final_population", "doc_type": "query_recipe", "text": "Recipe: maximum or highest final population. Query simulations table. Use MAX(final_population) to find maximum value. Or use ORDER BY final_population DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "final_population", "join_hints": [], "keywords": ["best", "final", "highest", "max", "maximum", "most", "population", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_final_population", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest final population. Query simulations table. Use MIN(final_population) to find minimum value. Or use ORDER BY final_population ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "final_population", "join_hints": [], "keywords": ["final", "least", "lowest", "min", "minimum", "population", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.Simulation.process_id", "doc_type": "schema_column", "text": "Column: Simulation.process_id (table simulations) — integer foreign key identifier Used to track or store identifier. Common query patterns: MAX(process_id) or MIN(process_id) for min/max, WHERE process_id > value for numeric filtering.", "metadata": {"model": "Simulation", "table": "simulations", "column": "process_id", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["id", "process"]}}
{"id": "query_recipe:simulations.process_id", "doc_type": "query_recipe", "text": "Recipe: access process_id from simulations. Filter by simulations.process_id to find specific records.. Return Simulation.process_id", "metadata": {"model": "Simulation", "table": "simulations", "column": "process_id", "join_hints": ["simulations.id -> simulation_configs.simulation_id", "simulations.experiment_id -> experiments.id"], "keywords": ["id", "process"], "semantics": null}}
{"id": "query_recipe:maximum_process_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest process id. Query simulations table. Use MAX(process_id) to find maximum value. Or use ORDER BY process_id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "process_id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "process", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_process_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest process id. Query simulations table. Use MIN(process_id) to find minimum value. Or use ORDER BY process_id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "process_id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "process", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.Simulation.current_step", "doc_type": "schema_column", "text": "Column: Simulation.current_step (table simulations) — integer Used to track or store data field. Default: 0. Common query patterns: MAX(current_step) or MIN(current_step) for min/max, WHERE current_step > value for numeric filtering.", "metadata": {"model": "Simulation", "table": "simulations", "column": "current_step", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["current", "step"]}}
{"id": "query_recipe:maximum_current_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest current step. Query simulations table. Use MAX(current_step) to find maximum value. Or use ORDER BY current_step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "current_step", "join_hints": [], "keywords": ["best", "current", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_current_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest current step. Query simulations table. Use MIN(current_step) to find minimum value. Or use ORDER BY current_step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "current_step", "join_hints": [], "keywords": ["current", "least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.Simulation.experiment_id", "doc_type": "schema_column", "text": "Column: Simulation.experiment_id (table simulations) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "Simulation", "table": "simulations", "column": "experiment_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["experiment", "id"]}}
{"id": "query_recipe:simulations.experiment_id", "doc_type": "query_recipe", "text": "Recipe: access experiment_id from simulations. Filter by simulations.experiment_id to find specific records.. Return Simulation.experiment_id", "metadata": {"model": "Simulation", "table": "simulations", "column": "experiment_id", "join_hints": ["simulations.id -> simulation_configs.simulation_id", "simulations.experiment_id -> experiments.id"], "keywords": ["experiment", "id"], "semantics": null}}
{"id": "schema_column:models.simulation.Simulation.iteration", "doc_type": "schema_column", "text": "Column: Simulation.iteration (table simulations) — integer Used to track or store data field. Common query patterns: MAX(iteration) or MIN(iteration) for min/max, WHERE iteration > value for numeric filtering.", "metadata": {"model": "Simulation", "table": "simulations", "column": "iteration", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["iteration"]}}
{"id": "query_recipe:maximum_iteration", "doc_type": "query_recipe", "text": "Recipe: maximum or highest iteration. Query simulations table. Use MAX(iteration) to find maximum value. Or use ORDER BY iteration DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "iteration", "join_hints": [], "keywords": ["best", "highest", "iteration", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_iteration", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest iteration. Query simulations table. Use MIN(iteration) to find minimum value. Or use ORDER BY iteration ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "Simulation", "table": "simulations", "column": "iteration", "join_hints": [], "keywords": ["iteration", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "query_recipe:simulations_linked_to_simulation_configs", "doc_type": "query_recipe", "text": "Recipe: simulation linked to simulationconfig. Join simulations to simulation_configs on simulations.id -> simulation_configs.simulation_id. Filter by simulations fields to find specific records. Return related simulation_configs records or simulation_configs fields.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": ["simulations.id -> simulation_configs.simulation_id"], "keywords": ["config", "connection", "linked", "related", "relationship", "simulation", "simulationconfig"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:simulation_configs_for_simulations", "doc_type": "query_recipe", "text": "Recipe: simulationconfig for simulation. Join simulation_configs to simulations on simulations.id -> simulation_configs.simulation_id. Filter by simulations fields to find specific simulation. Return related simulation_configs records.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": null, "join_hints": ["simulations.id -> simulation_configs.simulation_id"], "keywords": ["associated", "belongs", "for", "simulation", "simulationconfig"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:simulations_linked_to_experiments", "doc_type": "query_recipe", "text": "Recipe: simulation linked to experiment. Join simulations to experiments on simulations.experiment_id -> experiments.id. Filter by simulations fields to find specific records. Return related experiments records or experiments fields.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": ["simulations.experiment_id -> experiments.id"], "keywords": ["connection", "experiment", "linked", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_for_simulations", "doc_type": "query_recipe", "text": "Recipe: experiment for simulation. Join experiments to simulations on simulations.experiment_id -> experiments.id. Filter by simulations fields to find specific simulation. Return related experiments records.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["simulations.experiment_id -> experiments.id"], "keywords": ["associated", "belongs", "experiment", "for", "simulation"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:list_all_simulations_names", "doc_type": "query_recipe", "text": "Recipe: list all simulation names. Query simulations table. Use SELECT name FROM simulations. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "Simulation", "table": "simulations", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:simulations_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: simulation names and descriptions. Query simulations table. Use SELECT name, description FROM simulations. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_simulations", "doc_type": "query_recipe", "text": "Recipe: all simulations. Query simulations table. Use SELECT * FROM simulations or SELECT specific columns. Optionally filter by conditions if specified. Return all records from simulations.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "simulation"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.SimulationConfig", "doc_type": "schema_model", "text": "Model: SimulationConfig (table simulation_configs) — Detailed simulation configuration. This model tracks simulation executions, status, and results. Key columns: simulation id (identifier), template name (name or label for identification), created at (timestamp when record was created) Commonly used for: simulation execution tracking, temporal queries and filtering Example queries: 'simulationconfig status', 'simulationconfig information', 'simulationconfig names' Relationships: related to simulation via simulation", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.SimulationConfig.id", "doc_type": "schema_column", "text": "Column: SimulationConfig.id (table simulation_configs) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:simulation_configs.id", "doc_type": "query_recipe", "text": "Recipe: access id from simulation_configs. Filter by simulation_configs.id to find specific records.. Return SimulationConfig.id", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "id", "join_hints": ["simulation_configs.simulation_id -> simulations.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.simulation.SimulationConfig.simulation_id", "doc_type": "schema_column", "text": "Column: SimulationConfig.simulation_id (table simulation_configs) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:simulation_configs.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from simulation_configs. Filter by simulation_configs.simulation_id to find specific records.. Return SimulationConfig.simulation_id", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "simulation_id", "join_hints": ["simulation_configs.simulation_id -> simulations.id"], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.simulation.SimulationConfig.parameters", "doc_type": "schema_column", "text": "Column: SimulationConfig.parameters (table simulation_configs) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "parameters", "type": "JSON", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["parameters"]}}
{"id": "schema_column:models.simulation.SimulationConfig.template_name", "doc_type": "schema_column", "text": "Column: SimulationConfig.template_name (table simulation_configs) — varchar name or label Used to track or store name or label for identification. Common query patterns: WHERE template_name = 'value' for exact match, WHERE template_name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "template_name", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["label", "labels", "name", "names", "template", "title", "titles"]}}
{"id": "query_recipe:simulation_configs.template_name", "doc_type": "query_recipe", "text": "Recipe: access template_name from simulation_configs. Filter by simulation_configs.template_name to find specific records.. Return SimulationConfig.template_name", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "template_name", "join_hints": ["simulation_configs.simulation_id -> simulations.id"], "keywords": ["label", "labels", "name", "names", "template", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.simulation.SimulationConfig.template_version", "doc_type": "schema_column", "text": "Column: SimulationConfig.template_version (table simulation_configs) — varchar Used to track or store data field.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "template_version", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["template", "version"]}}
{"id": "schema_column:models.simulation.SimulationConfig.created_at", "doc_type": "schema_column", "text": "Column: SimulationConfig.created_at (table simulation_configs) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: simulationconfig created at in specific year or date range. Query simulation_configs table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulationconfig created at in the last week. Query simulation_configs table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:simulation_configs_linked_to_simulations", "doc_type": "query_recipe", "text": "Recipe: simulationconfig linked to simulation. Join simulation_configs to simulations on simulation_configs.simulation_id -> simulations.id. Filter by simulation_configs fields to find specific records. Return related simulations records or simulations fields.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": null, "join_hints": ["simulation_configs.simulation_id -> simulations.id"], "keywords": ["connection", "linked", "related", "relationship", "simulation"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:simulations_for_simulation_configs", "doc_type": "query_recipe", "text": "Recipe: simulation for simulationconfig. Join simulations to simulation_configs on simulation_configs.simulation_id -> simulations.id. Filter by simulation_configs fields to find specific simulationconfig. Return related simulations records.", "metadata": {"model": "Simulation", "table": "simulations", "column": null, "join_hints": ["simulation_configs.simulation_id -> simulations.id"], "keywords": ["associated", "belongs", "for", "simulation", "simulationconfig"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:list_all_simulation_configs_names", "doc_type": "query_recipe", "text": "Recipe: list all simulationconfig names. Query simulation_configs table. Use SELECT template_name FROM simulation_configs. Optionally filter by conditions if specified. Order by template_name ASC for alphabetical order. Return all template_name values.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": "template_name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "template", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:all_simulation_configs", "doc_type": "query_recipe", "text": "Recipe: all simulationconfigs. Query simulation_configs table. Use SELECT * FROM simulation_configs or SELECT specific columns. Optionally filter by conditions if specified. Return all records from simulation_configs.", "metadata": {"model": "SimulationConfig", "table": "simulation_configs", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "simulationconfig"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.SimulationMetrics", "doc_type": "schema_model", "text": "Model: SimulationMetrics (table simulation_metrics) — Historical metrics for each simulation step. This model tracks simulation executions, status, and results. Key columns: simulation id (identifier) Commonly used for: simulation execution tracking Example queries: 'simulationmetrics status', 'simulationmetrics information'", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.SimulationMetrics.id", "doc_type": "schema_column", "text": "Column: SimulationMetrics.id (table simulation_metrics) — integer Used to track or store data field. Required field. Common query patterns: MAX(id) or MIN(id) for min/max, WHERE id > value for numeric filtering.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "id", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:simulation_metrics.id", "doc_type": "query_recipe", "text": "Recipe: access id from simulation_metrics. Filter by simulation_metrics.id to find specific records.. Return SimulationMetrics.id", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "query_recipe:maximum_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest id. Query simulation_metrics table. Use MAX(id) to find maximum value. Or use ORDER BY id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest id. Query simulation_metrics table. Use MIN(id) to find minimum value. Or use ORDER BY id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.SimulationMetrics.simulation_id", "doc_type": "schema_column", "text": "Column: SimulationMetrics.simulation_id (table simulation_metrics) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:simulation_metrics.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from simulation_metrics. Filter by simulation_metrics.simulation_id to find specific records.. Return SimulationMetrics.simulation_id", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.simulation.SimulationMetrics.step", "doc_type": "schema_column", "text": "Column: SimulationMetrics.step (table simulation_metrics) — integer Used to track or store data field. Required field. Common query patterns: MAX(step) or MIN(step) for min/max, WHERE step > value for numeric filtering.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "step", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["step"]}}
{"id": "query_recipe:maximum_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest step. Query simulation_metrics table. Use MAX(step) to find maximum value. Or use ORDER BY step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "step", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest step. Query simulation_metrics table. Use MIN(step) to find minimum value. Or use ORDER BY step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "step", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.SimulationMetrics.timestamp", "doc_type": "schema_column", "text": "Column: SimulationMetrics.timestamp (table simulation_metrics) — datetime timestamp or duration Used to track or store timestamp or duration. Default: function utc_now. Common query patterns: WHERE YEAR(timestamp) = year for year filtering, WHERE timestamp BETWEEN start AND end for date ranges.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "timestamp", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["duration", "elapsed", "runtime", "time", "timestamp"]}}
{"id": "query_recipe:timestamp_last_week", "doc_type": "query_recipe", "text": "Recipe: simulationmetrics timestamp in the last week. Query simulation_metrics table. Filter by timestamp >= NOW() - INTERVAL '7' DAYS or WHERE timestamp >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "timestamp", "join_hints": [], "keywords": ["duration", "elapsed", "last week", "past", "recent", "runtime", "since", "time", "timestamp"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.SimulationMetrics.metrics", "doc_type": "schema_column", "text": "Column: SimulationMetrics.metrics (table simulation_metrics) — JSON object Used to track or store data field. Required field.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": "metrics", "type": "JSON", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["metrics"]}}
{"id": "query_recipe:all_simulation_metrics", "doc_type": "query_recipe", "text": "Recipe: all simulationmetricss. Query simulation_metrics table. Use SELECT * FROM simulation_metrics or SELECT specific columns. Optionally filter by conditions if specified. Return all records from simulation_metrics.", "metadata": {"model": "SimulationMetrics", "table": "simulation_metrics", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "simulationmetrics"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.AgentSnapshot", "doc_type": "schema_model", "text": "Model: AgentSnapshot (table agent_snapshots) — Agent positions and state at specific simulation steps.\n\n    Agent Data Format Specification:\n    --------------------------------\n    The agent_data field stores a compact JSON array of agent states to minimize storage.\n    Each agent is represented as an array with exactly 6 elements in this order:\n\n    Index | Field      | Type   | Description\n    ------|------------|--------|--------------------------------------------\n    0     | id         | string | Unique agent identifier (UUID)\n    1     | x          | float  | Agent's x-coordinate in world space\n    2     | y          | float  | Agent's y-coordinate in world space\n    3     | health     | float  | Agent's health value (0.0 - 100.0)\n    4     | resources  | float  | Agent's resource count\n    5     | age        | int    | Agent's age in simulation steps\n\n    Example format:\n    [\n        [\"agent-uuid-1\", 150.5, 200.3, 95.0, 50.0, 10],\n        [\"agent-uuid-2\", 300.2, 100.8, 80.5, 30.0, 15],\n        ...\n    ]\n\n    IMPORTANT: This format must remain stable. Any changes to the array structure\n    require a database migration and updates to serialization/deserialization code. Key columns: simulation id (identifier)", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.AgentSnapshot.id", "doc_type": "schema_column", "text": "Column: AgentSnapshot.id (table agent_snapshots) — integer Used to track or store data field. Required field. Common query patterns: MAX(id) or MIN(id) for min/max, WHERE id > value for numeric filtering.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "id", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:agent_snapshots.id", "doc_type": "query_recipe", "text": "Recipe: access id from agent_snapshots. Filter by agent_snapshots.id to find specific records.. Return AgentSnapshot.id", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "query_recipe:maximum_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest id. Query agent_snapshots table. Use MAX(id) to find maximum value. Or use ORDER BY id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest id. Query agent_snapshots table. Use MIN(id) to find minimum value. Or use ORDER BY id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentSnapshot.simulation_id", "doc_type": "schema_column", "text": "Column: AgentSnapshot.simulation_id (table agent_snapshots) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:agent_snapshots.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from agent_snapshots. Filter by agent_snapshots.simulation_id to find specific records.. Return AgentSnapshot.simulation_id", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentSnapshot.step", "doc_type": "schema_column", "text": "Column: AgentSnapshot.step (table agent_snapshots) — integer Used to track or store data field. Required field. Common query patterns: MAX(step) or MIN(step) for min/max, WHERE step > value for numeric filtering.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "step", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["step"]}}
{"id": "query_recipe:maximum_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest step. Query agent_snapshots table. Use MAX(step) to find maximum value. Or use ORDER BY step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "step", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest step. Query agent_snapshots table. Use MIN(step) to find minimum value. Or use ORDER BY step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "step", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentSnapshot.timestamp", "doc_type": "schema_column", "text": "Column: AgentSnapshot.timestamp (table agent_snapshots) — datetime timestamp or duration Used to track or store timestamp or duration. Default: function utc_now. Common query patterns: WHERE YEAR(timestamp) = year for year filtering, WHERE timestamp BETWEEN start AND end for date ranges.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "timestamp", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["duration", "elapsed", "runtime", "time", "timestamp"]}}
{"id": "query_recipe:timestamp_last_week", "doc_type": "query_recipe", "text": "Recipe: agentsnapshot timestamp in the last week. Query agent_snapshots table. Filter by timestamp >= NOW() - INTERVAL '7' DAYS or WHERE timestamp >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "timestamp", "join_hints": [], "keywords": ["duration", "elapsed", "last week", "past", "recent", "runtime", "since", "time", "timestamp"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.AgentSnapshot.agent_data", "doc_type": "schema_column", "text": "Column: AgentSnapshot.agent_data (table agent_snapshots) — JSON object Used to track or store data field. Required field.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": "agent_data", "type": "JSON", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["agent", "data"]}}
{"id": "query_recipe:all_agent_snapshots", "doc_type": "query_recipe", "text": "Recipe: all agentsnapshots. Query agent_snapshots table. Use SELECT * FROM agent_snapshots or SELECT specific columns. Optionally filter by conditions if specified. Return all records from agent_snapshots.", "metadata": {"model": "AgentSnapshot", "table": "agent_snapshots", "column": null, "join_hints": [], "keywords": ["agentsnapshot", "all", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.AgentIntrospection", "doc_type": "schema_model", "text": "Model: AgentIntrospection (table agent_introspection) — Extended agent introspection data for deep analysis.\n\n    Stores detailed cognitive state, memory, policy, and attention data\n    for individual agents at specific simulation steps. Key columns: simulation id (identifier), agent id (identifier), memory state (current status or state), policy state (current status or state) Example queries: 'agentintrospection status'", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.AgentIntrospection.id", "doc_type": "schema_column", "text": "Column: AgentIntrospection.id (table agent_introspection) — integer Used to track or store data field. Required field. Common query patterns: MAX(id) or MIN(id) for min/max, WHERE id > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "id", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:agent_introspection.id", "doc_type": "query_recipe", "text": "Recipe: access id from agent_introspection. Filter by agent_introspection.id to find specific records.. Return AgentIntrospection.id", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "query_recipe:maximum_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest id. Query agent_introspection table. Use MAX(id) to find maximum value. Or use ORDER BY id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest id. Query agent_introspection table. Use MIN(id) to find minimum value. Or use ORDER BY id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.simulation_id", "doc_type": "schema_column", "text": "Column: AgentIntrospection.simulation_id (table agent_introspection) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:agent_introspection.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from agent_introspection. Filter by agent_introspection.simulation_id to find specific records.. Return AgentIntrospection.simulation_id", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentIntrospection.agent_id", "doc_type": "schema_column", "text": "Column: AgentIntrospection.agent_id (table agent_introspection) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "agent_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["agent", "id"]}}
{"id": "query_recipe:agent_introspection.agent_id", "doc_type": "query_recipe", "text": "Recipe: access agent_id from agent_introspection. Filter by agent_introspection.agent_id to find specific records.. Return AgentIntrospection.agent_id", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "agent_id", "join_hints": [], "keywords": ["agent", "id"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentIntrospection.step", "doc_type": "schema_column", "text": "Column: AgentIntrospection.step (table agent_introspection) — integer Used to track or store data field. Required field. Common query patterns: MAX(step) or MIN(step) for min/max, WHERE step > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "step", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["step"]}}
{"id": "query_recipe:maximum_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest step. Query agent_introspection table. Use MAX(step) to find maximum value. Or use ORDER BY step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "step", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest step. Query agent_introspection table. Use MIN(step) to find minimum value. Or use ORDER BY step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "step", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.timestamp", "doc_type": "schema_column", "text": "Column: AgentIntrospection.timestamp (table agent_introspection) — datetime timestamp or duration Used to track or store timestamp or duration. Default: function utc_now. Common query patterns: WHERE YEAR(timestamp) = year for year filtering, WHERE timestamp BETWEEN start AND end for date ranges.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "timestamp", "type": "DATETIME", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["duration", "elapsed", "runtime", "time", "timestamp"]}}
{"id": "query_recipe:timestamp_last_week", "doc_type": "query_recipe", "text": "Recipe: agentintrospection timestamp in the last week. Query agent_introspection table. Filter by timestamp >= NOW() - INTERVAL '7' DAYS or WHERE timestamp >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "timestamp", "join_hints": [], "keywords": ["duration", "elapsed", "last week", "past", "recent", "runtime", "since", "time", "timestamp"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.simulation.AgentIntrospection.position_x", "doc_type": "schema_column", "text": "Column: AgentIntrospection.position_x (table agent_introspection) — numeric Used to track or store data field. Common query patterns: MAX(position_x) or MIN(position_x) for min/max, WHERE position_x > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_x", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["position", "x"]}}
{"id": "query_recipe:maximum_position_x", "doc_type": "query_recipe", "text": "Recipe: maximum or highest position x. Query agent_introspection table. Use MAX(position_x) to find maximum value. Or use ORDER BY position_x DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_x", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "position", "top", "x"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_position_x", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest position x. Query agent_introspection table. Use MIN(position_x) to find minimum value. Or use ORDER BY position_x ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_x", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "position", "smallest", "x"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.position_y", "doc_type": "schema_column", "text": "Column: AgentIntrospection.position_y (table agent_introspection) — numeric Used to track or store data field. Common query patterns: MAX(position_y) or MIN(position_y) for min/max, WHERE position_y > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_y", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["position", "y"]}}
{"id": "query_recipe:maximum_position_y", "doc_type": "query_recipe", "text": "Recipe: maximum or highest position y. Query agent_introspection table. Use MAX(position_y) to find maximum value. Or use ORDER BY position_y DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_y", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "position", "top", "y"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_position_y", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest position y. Query agent_introspection table. Use MIN(position_y) to find minimum value. Or use ORDER BY position_y ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "position_y", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "position", "smallest", "y"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.health", "doc_type": "schema_column", "text": "Column: AgentIntrospection.health (table agent_introspection) — numeric Used to track or store data field. Common query patterns: MAX(health) or MIN(health) for min/max, WHERE health > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "health", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["health"]}}
{"id": "query_recipe:maximum_health", "doc_type": "query_recipe", "text": "Recipe: maximum or highest health. Query agent_introspection table. Use MAX(health) to find maximum value. Or use ORDER BY health DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "health", "join_hints": [], "keywords": ["best", "health", "highest", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_health", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest health. Query agent_introspection table. Use MIN(health) to find minimum value. Or use ORDER BY health ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "health", "join_hints": [], "keywords": ["health", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.resources", "doc_type": "schema_column", "text": "Column: AgentIntrospection.resources (table agent_introspection) — numeric Used to track or store data field. Common query patterns: MAX(resources) or MIN(resources) for min/max, WHERE resources > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "resources", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["resources"]}}
{"id": "query_recipe:maximum_resources", "doc_type": "query_recipe", "text": "Recipe: maximum or highest resources. Query agent_introspection table. Use MAX(resources) to find maximum value. Or use ORDER BY resources DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "resources", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "resources", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_resources", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest resources. Query agent_introspection table. Use MIN(resources) to find minimum value. Or use ORDER BY resources ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "resources", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "resources", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.age", "doc_type": "schema_column", "text": "Column: AgentIntrospection.age (table agent_introspection) — integer Used to track or store data field. Common query patterns: MAX(age) or MIN(age) for min/max, WHERE age > value for numeric filtering.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "age", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["age"]}}
{"id": "query_recipe:maximum_age", "doc_type": "query_recipe", "text": "Recipe: maximum or highest age. Query agent_introspection table. Use MAX(age) to find maximum value. Or use ORDER BY age DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "age", "join_hints": [], "keywords": ["age", "best", "highest", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_age", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest age. Query agent_introspection table. Use MIN(age) to find minimum value. Or use ORDER BY age ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "age", "join_hints": [], "keywords": ["age", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentIntrospection.memory_state", "doc_type": "schema_column", "text": "Column: AgentIntrospection.memory_state (table agent_introspection) — JSON object Used to track or store current status or state. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE memory_state = 'status_value' for filtering, COUNT(*) WHERE memory_state = 'status' for counting by status.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "type": "JSON", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["memory", "state"]}}
{"id": "query_recipe:memory_state_running", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status running. Query agent_introspection table. Filter by memory_state = 'running' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are running. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["condition", "memory", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:memory_state_completed", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status completed. Query agent_introspection table. Filter by memory_state = 'completed' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are completed. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["completed", "condition", "memory", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:memory_state_active", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status active. Query agent_introspection table. Filter by memory_state = 'active' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are active. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["active", "condition", "memory", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:memory_state_failed", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status failed. Query agent_introspection table. Filter by memory_state = 'failed' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are failed. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["condition", "failed", "memory", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:memory_state_pending", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status pending. Query agent_introspection table. Filter by memory_state = 'pending' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are pending. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["condition", "memory", "pending", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:memory_state_success", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status success. Query agent_introspection table. Filter by memory_state = 'success' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are success. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["condition", "memory", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_memory_state", "doc_type": "query_recipe", "text": "Recipe: how many agentintrospections with specific status. Query agent_introspection table. Use COUNT(*) with filter WHERE memory_state = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "memory_state", "join_hints": [], "keywords": ["count", "how many", "memory", "number", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.simulation.AgentIntrospection.policy_state", "doc_type": "schema_column", "text": "Column: AgentIntrospection.policy_state (table agent_introspection) — JSON object Used to track or store current status or state. Example values: 'active', 'inactive', 'pending', 'completed', 'failed'. Common query patterns: WHERE policy_state = 'status_value' for filtering, COUNT(*) WHERE policy_state = 'status' for counting by status.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "type": "JSON", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["policy", "state"]}}
{"id": "query_recipe:policy_state_running", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status running. Query agent_introspection table. Filter by policy_state = 'running' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are running. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["condition", "policy", "running", "state", "status"], "semantics": "Status filtering: running", "recipe_type": "status"}}
{"id": "query_recipe:policy_state_completed", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status completed. Query agent_introspection table. Filter by policy_state = 'completed' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are completed. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["completed", "condition", "policy", "state", "status"], "semantics": "Status filtering: completed", "recipe_type": "status"}}
{"id": "query_recipe:policy_state_active", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status active. Query agent_introspection table. Filter by policy_state = 'active' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are active. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["active", "condition", "policy", "state", "status"], "semantics": "Status filtering: active", "recipe_type": "status"}}
{"id": "query_recipe:policy_state_failed", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status failed. Query agent_introspection table. Filter by policy_state = 'failed' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are failed. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["condition", "failed", "policy", "state", "status"], "semantics": "Status filtering: failed", "recipe_type": "status"}}
{"id": "query_recipe:policy_state_pending", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status pending. Query agent_introspection table. Filter by policy_state = 'pending' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are pending. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["condition", "pending", "policy", "state", "status"], "semantics": "Status filtering: pending", "recipe_type": "status"}}
{"id": "query_recipe:policy_state_success", "doc_type": "query_recipe", "text": "Recipe: agentintrospection with status success. Query agent_introspection table. Filter by policy_state = 'success' (or appropriate status value). Use COUNT(*) to count how many agentintrospections are success. Return matching records or count.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["condition", "policy", "state", "status", "success"], "semantics": "Status filtering: success", "recipe_type": "status"}}
{"id": "query_recipe:how_many_policy_state", "doc_type": "query_recipe", "text": "Recipe: how many agentintrospections with specific status. Query agent_introspection table. Use COUNT(*) with filter WHERE policy_state = 'status_value'. Return the count of records matching the status condition.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "policy_state", "join_hints": [], "keywords": ["count", "how many", "number", "policy", "state", "status"], "semantics": "Count by status", "recipe_type": "status"}}
{"id": "schema_column:models.simulation.AgentIntrospection.attention", "doc_type": "schema_column", "text": "Column: AgentIntrospection.attention (table agent_introspection) — JSON object Used to track or store data field.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": "attention", "type": "JSON", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["attention"]}}
{"id": "query_recipe:all_agent_introspection", "doc_type": "query_recipe", "text": "Recipe: all agentintrospections. Query agent_introspection table. Use SELECT * FROM agent_introspection or SELECT specific columns. Optionally filter by conditions if specified. Return all records from agent_introspection.", "metadata": {"model": "AgentIntrospection", "table": "agent_introspection", "column": null, "join_hints": [], "keywords": ["agentintrospection", "all", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.simulation.AgentLineage", "doc_type": "schema_model", "text": "Model: AgentLineage (table agent_lineage) — Agent lineage and genetic tracking for evolutionary analysis.\n\n    Tracks parent-child relationships, genetic parameters, and mutations\n    to enable family tree visualization and evolutionary analysis. Key columns: simulation id (identifier), agent id (identifier), parent id (identifier)", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "source_file": "backend/models/simulation.py"}}
{"id": "schema_column:models.simulation.AgentLineage.id", "doc_type": "schema_column", "text": "Column: AgentLineage.id (table agent_lineage) — integer Used to track or store data field. Required field. Common query patterns: MAX(id) or MIN(id) for min/max, WHERE id > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "id", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id"]}}
{"id": "query_recipe:agent_lineage.id", "doc_type": "query_recipe", "text": "Recipe: access id from agent_lineage. Filter by agent_lineage.id to find specific records.. Return AgentLineage.id", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "query_recipe:maximum_id", "doc_type": "query_recipe", "text": "Recipe: maximum or highest id. Query agent_lineage table. Use MAX(id) to find maximum value. Or use ORDER BY id DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "id", "join_hints": [], "keywords": ["best", "highest", "id", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_id", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest id. Query agent_lineage table. Use MIN(id) to find minimum value. Or use ORDER BY id ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "id", "join_hints": [], "keywords": ["id", "least", "lowest", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.simulation_id", "doc_type": "schema_column", "text": "Column: AgentLineage.simulation_id (table agent_lineage) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "simulation_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:agent_lineage.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from agent_lineage. Filter by agent_lineage.simulation_id to find specific records.. Return AgentLineage.simulation_id", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentLineage.agent_id", "doc_type": "schema_column", "text": "Column: AgentLineage.agent_id (table agent_lineage) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "agent_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["agent", "id"]}}
{"id": "query_recipe:agent_lineage.agent_id", "doc_type": "query_recipe", "text": "Recipe: access agent_id from agent_lineage. Filter by agent_lineage.agent_id to find specific records.. Return AgentLineage.agent_id", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "agent_id", "join_hints": [], "keywords": ["agent", "id"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentLineage.parent_id", "doc_type": "schema_column", "text": "Column: AgentLineage.parent_id (table agent_lineage) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "parent_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["id", "parent"]}}
{"id": "query_recipe:agent_lineage.parent_id", "doc_type": "query_recipe", "text": "Recipe: access parent_id from agent_lineage. Filter by agent_lineage.parent_id to find specific records.. Return AgentLineage.parent_id", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "parent_id", "join_hints": [], "keywords": ["id", "parent"], "semantics": null}}
{"id": "schema_column:models.simulation.AgentLineage.birth_step", "doc_type": "schema_column", "text": "Column: AgentLineage.birth_step (table agent_lineage) — integer Used to track or store data field. Required field. Common query patterns: MAX(birth_step) or MIN(birth_step) for min/max, WHERE birth_step > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "birth_step", "type": "INTEGER", "nullable": false, "source_file": "backend/models/simulation.py", "keywords": ["birth", "step"]}}
{"id": "query_recipe:maximum_birth_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest birth step. Query agent_lineage table. Use MAX(birth_step) to find maximum value. Or use ORDER BY birth_step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "birth_step", "join_hints": [], "keywords": ["best", "birth", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_birth_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest birth step. Query agent_lineage table. Use MIN(birth_step) to find minimum value. Or use ORDER BY birth_step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "birth_step", "join_hints": [], "keywords": ["birth", "least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.death_step", "doc_type": "schema_column", "text": "Column: AgentLineage.death_step (table agent_lineage) — integer Used to track or store data field. Common query patterns: MAX(death_step) or MIN(death_step) for min/max, WHERE death_step > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "death_step", "type": "INTEGER", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["death", "step"]}}
{"id": "query_recipe:maximum_death_step", "doc_type": "query_recipe", "text": "Recipe: maximum or highest death step. Query agent_lineage table. Use MAX(death_step) to find maximum value. Or use ORDER BY death_step DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "death_step", "join_hints": [], "keywords": ["best", "death", "highest", "max", "maximum", "most", "step", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_death_step", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest death step. Query agent_lineage table. Use MIN(death_step) to find minimum value. Or use ORDER BY death_step ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "death_step", "join_hints": [], "keywords": ["death", "least", "lowest", "min", "minimum", "smallest", "step"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.metabolism_rate", "doc_type": "schema_column", "text": "Column: AgentLineage.metabolism_rate (table agent_lineage) — numeric Used to track or store data field. Common query patterns: MAX(metabolism_rate) or MIN(metabolism_rate) for min/max, WHERE metabolism_rate > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "metabolism_rate", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["metabolism", "rate"]}}
{"id": "query_recipe:maximum_metabolism_rate", "doc_type": "query_recipe", "text": "Recipe: maximum or highest metabolism rate. Query agent_lineage table. Use MAX(metabolism_rate) to find maximum value. Or use ORDER BY metabolism_rate DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "metabolism_rate", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "metabolism", "most", "rate", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_metabolism_rate", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest metabolism rate. Query agent_lineage table. Use MIN(metabolism_rate) to find minimum value. Or use ORDER BY metabolism_rate ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "metabolism_rate", "join_hints": [], "keywords": ["least", "lowest", "metabolism", "min", "minimum", "rate", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.max_health", "doc_type": "schema_column", "text": "Column: AgentLineage.max_health (table agent_lineage) — numeric Used to track or store data field. Common query patterns: MAX(max_health) or MIN(max_health) for min/max, WHERE max_health > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_health", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["health", "max"]}}
{"id": "query_recipe:maximum_max_health", "doc_type": "query_recipe", "text": "Recipe: maximum or highest max health. Query agent_lineage table. Use MAX(max_health) to find maximum value. Or use ORDER BY max_health DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_health", "join_hints": [], "keywords": ["best", "health", "highest", "max", "maximum", "most", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_max_health", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest max health. Query agent_lineage table. Use MIN(max_health) to find minimum value. Or use ORDER BY max_health ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_health", "join_hints": [], "keywords": ["health", "least", "lowest", "max", "min", "minimum", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.max_resources", "doc_type": "schema_column", "text": "Column: AgentLineage.max_resources (table agent_lineage) — numeric Used to track or store data field. Common query patterns: MAX(max_resources) or MIN(max_resources) for min/max, WHERE max_resources > value for numeric filtering.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_resources", "type": "FLOAT", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["max", "resources"]}}
{"id": "query_recipe:maximum_max_resources", "doc_type": "query_recipe", "text": "Recipe: maximum or highest max resources. Query agent_lineage table. Use MAX(max_resources) to find maximum value. Or use ORDER BY max_resources DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_resources", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "resources", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_max_resources", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest max resources. Query agent_lineage table. Use MIN(max_resources) to find minimum value. Or use ORDER BY max_resources ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "max_resources", "join_hints": [], "keywords": ["least", "lowest", "max", "min", "minimum", "resources", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.simulation.AgentLineage.mutations", "doc_type": "schema_column", "text": "Column: AgentLineage.mutations (table agent_lineage) — JSON object Used to track or store data field.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": "mutations", "type": "JSON", "nullable": true, "source_file": "backend/models/simulation.py", "keywords": ["mutations"]}}
{"id": "query_recipe:all_agent_lineage", "doc_type": "query_recipe", "text": "Recipe: all agentlineages. Query agent_lineage table. Use SELECT * FROM agent_lineage or SELECT specific columns. Optionally filter by conditions if specified. Return all records from agent_lineage.", "metadata": {"model": "AgentLineage", "table": "agent_lineage", "column": null, "join_hints": [], "keywords": ["agentlineage", "all", "every", "list"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.template.SimulationTemplate", "doc_type": "schema_model", "text": "Model: SimulationTemplate (table simulation_templates) — Simulation template model - stores reusable simulation configurations. This model tracks simulation executions, status, and results. Key columns: name (name or label for identification), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: simulation execution tracking, temporal queries and filtering Example queries: 'simulationtemplate status', 'simulationtemplate information', 'simulationtemplate names'", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "source_file": "backend/models/template.py"}}
{"id": "schema_column:models.template.SimulationTemplate.id", "doc_type": "schema_column", "text": "Column: SimulationTemplate.id (table simulation_templates) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/template.py", "keywords": ["id"]}}
{"id": "query_recipe:simulation_templates.id", "doc_type": "query_recipe", "text": "Recipe: access id from simulation_templates. Filter by simulation_templates.id to find specific records.. Return SimulationTemplate.id", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.template.SimulationTemplate.name", "doc_type": "schema_column", "text": "Column: SimulationTemplate.name (table simulation_templates) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/template.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:simulation_templates.name", "doc_type": "query_recipe", "text": "Recipe: access name from simulation_templates. Filter by simulation_templates.name to find specific records.. Return SimulationTemplate.name", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "name", "join_hints": [], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.template.SimulationTemplate.description", "doc_type": "schema_column", "text": "Column: SimulationTemplate.description (table simulation_templates) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/template.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.template.SimulationTemplate.parameters", "doc_type": "schema_column", "text": "Column: SimulationTemplate.parameters (table simulation_templates) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "parameters", "type": "JSON", "nullable": false, "source_file": "backend/models/template.py", "keywords": ["parameters"]}}
{"id": "schema_column:models.template.SimulationTemplate.created_at", "doc_type": "schema_column", "text": "Column: SimulationTemplate.created_at (table simulation_templates) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/template.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: simulationtemplate created at in specific year or date range. Query simulation_templates table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulationtemplate created at in the last week. Query simulation_templates table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.template.SimulationTemplate.updated_at", "doc_type": "schema_column", "text": "Column: SimulationTemplate.updated_at (table simulation_templates) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/template.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: simulationtemplate updated at recently. Query simulation_templates table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: simulationtemplate updated at in the last week. Query simulation_templates table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.template.SimulationTemplate.category", "doc_type": "schema_column", "text": "Column: SimulationTemplate.category (table simulation_templates) — varchar Used to track or store data field. Default: custom.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "category", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/template.py", "keywords": ["category"]}}
{"id": "query_recipe:list_all_simulation_templates_names", "doc_type": "query_recipe", "text": "Recipe: list all simulationtemplate names. Query simulation_templates table. Use SELECT name FROM simulation_templates. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:simulation_templates_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: simulationtemplate names and descriptions. Query simulation_templates table. Use SELECT name, description FROM simulation_templates. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_simulation_templates", "doc_type": "query_recipe", "text": "Recipe: all simulationtemplates. Query simulation_templates table. Use SELECT * FROM simulation_templates or SELECT specific columns. Optionally filter by conditions if specified. Return all records from simulation_templates.", "metadata": {"model": "SimulationTemplate", "table": "simulation_templates", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "simulationtemplate"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.program.Program", "doc_type": "schema_model", "text": "Model: Program (table programs) — Simulation program model - stores executable simulation programs. This model represents executable simulation programs and their metadata. Key columns: name (name or label for identification), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: program definitions and metadata, program identification and lookup, temporal queries and filtering Example queries: 'program information', 'program details', 'list all program names', 'program names' Relationships: related to programvariant via variants, related to programstatistics via statistics, related to programexecution via executions", "metadata": {"model": "Program", "table": "programs", "source_file": "backend/models/program.py"}}
{"id": "schema_column:models.program.Program.id", "doc_type": "schema_column", "text": "Column: Program.id (table programs) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "Program", "table": "programs", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id"]}}
{"id": "query_recipe:programs.id", "doc_type": "query_recipe", "text": "Recipe: access id from programs. Filter by programs.id to find specific records.. Return Program.id", "metadata": {"model": "Program", "table": "programs", "column": "id", "join_hints": ["programs.id -> program_variants.program_id", "programs.id -> program_statistics.program_id", "programs.id -> program_executions.program_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.program.Program.name", "doc_type": "schema_column", "text": "Column: Program.name (table programs) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "Program", "table": "programs", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:programs.name", "doc_type": "query_recipe", "text": "Recipe: access name from programs. Filter by programs.name to find specific records.. Return Program.name", "metadata": {"model": "Program", "table": "programs", "column": "name", "join_hints": ["programs.id -> program_variants.program_id", "programs.id -> program_statistics.program_id", "programs.id -> program_executions.program_id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.program.Program.description", "doc_type": "schema_column", "text": "Column: Program.description (table programs) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "Program", "table": "programs", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.program.Program.tags", "doc_type": "schema_column", "text": "Column: Program.tags (table programs) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "Program", "table": "programs", "column": "tags", "type": "JSON", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["tags"]}}
{"id": "schema_column:models.program.Program.parameters", "doc_type": "schema_column", "text": "Column: Program.parameters (table programs) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "Program", "table": "programs", "column": "parameters", "type": "JSON", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["parameters"]}}
{"id": "schema_column:models.program.Program.script_file", "doc_type": "schema_column", "text": "Column: Program.script_file (table programs) — varchar Used to track or store data field.", "metadata": {"model": "Program", "table": "programs", "column": "script_file", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["file", "script"]}}
{"id": "schema_column:models.program.Program.inline_code", "doc_type": "schema_column", "text": "Column: Program.inline_code (table programs) — text Used to track or store data field.", "metadata": {"model": "Program", "table": "programs", "column": "inline_code", "type": "TEXT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["code", "inline"]}}
{"id": "schema_column:models.program.Program.output_schema", "doc_type": "schema_column", "text": "Column: Program.output_schema (table programs) — JSON object Used to track or store data field.", "metadata": {"model": "Program", "table": "programs", "column": "output_schema", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["output", "schema"]}}
{"id": "schema_column:models.program.Program.post_processing_config", "doc_type": "schema_column", "text": "Column: Program.post_processing_config (table programs) — JSON object Used to track or store data field.", "metadata": {"model": "Program", "table": "programs", "column": "post_processing_config", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["config", "post", "processing"]}}
{"id": "schema_column:models.program.Program.created_at", "doc_type": "schema_column", "text": "Column: Program.created_at (table programs) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "Program", "table": "programs", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: program created at in specific year or date range. Query programs table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "Program", "table": "programs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: program created at in the last week. Query programs table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Program", "table": "programs", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.program.Program.updated_at", "doc_type": "schema_column", "text": "Column: Program.updated_at (table programs) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "Program", "table": "programs", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: program updated at recently. Query programs table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "Program", "table": "programs", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: program updated at in the last week. Query programs table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Program", "table": "programs", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.program.Program.category", "doc_type": "schema_column", "text": "Column: Program.category (table programs) — varchar Used to track or store data field. Default: custom.", "metadata": {"model": "Program", "table": "programs", "column": "category", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["category"]}}
{"id": "query_recipe:programs_linked_to_program_variants", "doc_type": "query_recipe", "text": "Recipe: program linked to programvariant. Join programs to program_variants on programs.id -> program_variants.program_id. Filter by programs fields to find specific records. Return related program_variants records or program_variants fields.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["programs.id -> program_variants.program_id"], "keywords": ["connection", "linked", "programvariant", "related", "relationship", "variants"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_variants_for_programs", "doc_type": "query_recipe", "text": "Recipe: programvariant for program. Join program_variants to programs on programs.id -> program_variants.program_id. Filter by programs fields to find specific program. Return related program_variants records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["programs.id -> program_variants.program_id"], "keywords": ["associated", "belongs", "for", "program", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:programs_linked_to_program_statistics", "doc_type": "query_recipe", "text": "Recipe: program linked to programstatistics. Join programs to program_statistics on programs.id -> program_statistics.program_id. Filter by programs fields to find specific records. Return related program_statistics records or program_statistics fields.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["programs.id -> program_statistics.program_id"], "keywords": ["connection", "linked", "programstatistics", "related", "relationship", "statistics"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_statistics_for_programs", "doc_type": "query_recipe", "text": "Recipe: programstatistics for program. Join program_statistics to programs on programs.id -> program_statistics.program_id. Filter by programs fields to find specific program. Return related program_statistics records.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": null, "join_hints": ["programs.id -> program_statistics.program_id"], "keywords": ["associated", "belongs", "for", "program", "programstatistics"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:programs_linked_to_program_executions", "doc_type": "query_recipe", "text": "Recipe: program linked to programexecution. Join programs to program_executions on programs.id -> program_executions.program_id. Filter by programs fields to find specific records. Return related program_executions records or program_executions fields.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["programs.id -> program_executions.program_id"], "keywords": ["connection", "executions", "linked", "programexecution", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_executions_for_programs", "doc_type": "query_recipe", "text": "Recipe: programexecution for program. Join program_executions to programs on programs.id -> program_executions.program_id. Filter by programs fields to find specific program. Return related program_executions records.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": null, "join_hints": ["programs.id -> program_executions.program_id"], "keywords": ["associated", "belongs", "for", "program", "programexecution"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:list_all_programs_names", "doc_type": "query_recipe", "text": "Recipe: list all program names. Query programs table. Use SELECT name FROM programs. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "Program", "table": "programs", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:programs_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: program names and descriptions. Query programs table. Use SELECT name, description FROM programs. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_programs", "doc_type": "query_recipe", "text": "Recipe: all programs. Query programs table. Use SELECT * FROM programs or SELECT specific columns. Optionally filter by conditions if specified. Return all records from programs.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "program"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.program.ProgramVariant", "doc_type": "schema_model", "text": "Model: ProgramVariant (table program_variants) — Program variant model - stores named modifications of programs. This model represents executable simulation programs and their metadata. Key columns: program id (identifier), name (name or label for identification), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: program definitions and metadata, program identification and lookup, temporal queries and filtering Example queries: 'programvariant information', 'programvariant details', 'list all programvariant names', 'programvariant names' Relationships: related to program via program, related to programstatistics via statistics, related to programexecution via executions", "metadata": {"model": "ProgramVariant", "table": "program_variants", "source_file": "backend/models/program.py"}}
{"id": "schema_column:models.program.ProgramVariant.id", "doc_type": "schema_column", "text": "Column: ProgramVariant.id (table program_variants) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id"]}}
{"id": "query_recipe:program_variants.id", "doc_type": "query_recipe", "text": "Recipe: access id from program_variants. Filter by program_variants.id to find specific records.. Return ProgramVariant.id", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "id", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.program_id", "doc_type": "schema_column", "text": "Column: ProgramVariant.program_id (table program_variants) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "program_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id", "program"]}}
{"id": "query_recipe:program_variants.program_id", "doc_type": "query_recipe", "text": "Recipe: access program_id from program_variants. Filter by program_variants.program_id to find specific records.. Return ProgramVariant.program_id", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "program_id", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["id", "program"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.name", "doc_type": "schema_column", "text": "Column: ProgramVariant.name (table program_variants) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:program_variants.name", "doc_type": "query_recipe", "text": "Recipe: access name from program_variants. Filter by program_variants.name to find specific records.. Return ProgramVariant.name", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "name", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.description", "doc_type": "schema_column", "text": "Column: ProgramVariant.description (table program_variants) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.program.ProgramVariant.parameter_overrides", "doc_type": "schema_column", "text": "Column: ProgramVariant.parameter_overrides (table program_variants) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "parameter_overrides", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["overrides", "parameter"]}}
{"id": "query_recipe:program_variants.parameter_overrides", "doc_type": "query_recipe", "text": "Recipe: access parameter_overrides from program_variants. Filter by program_variants.parameter_overrides to find specific records.. Return ProgramVariant.parameter_overrides", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "parameter_overrides", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["overrides", "parameter"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.code_overrides", "doc_type": "schema_column", "text": "Column: ProgramVariant.code_overrides (table program_variants) — text Used to track or store data field.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "code_overrides", "type": "TEXT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["code", "overrides"]}}
{"id": "query_recipe:program_variants.code_overrides", "doc_type": "query_recipe", "text": "Recipe: access code_overrides from program_variants. Filter by program_variants.code_overrides to find specific records.. Return ProgramVariant.code_overrides", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "code_overrides", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["code", "overrides"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.post_processing_overrides", "doc_type": "schema_column", "text": "Column: ProgramVariant.post_processing_overrides (table program_variants) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "post_processing_overrides", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["overrides", "post", "processing"]}}
{"id": "query_recipe:program_variants.post_processing_overrides", "doc_type": "query_recipe", "text": "Recipe: access post_processing_overrides from program_variants. Filter by program_variants.post_processing_overrides to find specific records.. Return ProgramVariant.post_processing_overrides", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "post_processing_overrides", "join_hints": ["program_variants.program_id -> programs.id", "program_variants.id -> program_statistics.variant_id", "program_variants.id -> program_executions.variant_id"], "keywords": ["overrides", "post", "processing"], "semantics": null}}
{"id": "schema_column:models.program.ProgramVariant.created_at", "doc_type": "schema_column", "text": "Column: ProgramVariant.created_at (table program_variants) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: programvariant created at in specific year or date range. Query program_variants table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: programvariant created at in the last week. Query program_variants table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.program.ProgramVariant.updated_at", "doc_type": "schema_column", "text": "Column: ProgramVariant.updated_at (table program_variants) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: programvariant updated at recently. Query program_variants table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: programvariant updated at in the last week. Query program_variants table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:program_variants_linked_to_programs", "doc_type": "query_recipe", "text": "Recipe: programvariant linked to program. Join program_variants to programs on program_variants.program_id -> programs.id. Filter by program_variants fields to find specific records. Return related programs records or programs fields.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["program_variants.program_id -> programs.id"], "keywords": ["connection", "linked", "program", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:programs_for_program_variants", "doc_type": "query_recipe", "text": "Recipe: program for programvariant. Join programs to program_variants on program_variants.program_id -> programs.id. Filter by program_variants fields to find specific programvariant. Return related programs records.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["program_variants.program_id -> programs.id"], "keywords": ["associated", "belongs", "for", "program", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_variants_linked_to_program_statistics", "doc_type": "query_recipe", "text": "Recipe: programvariant linked to programstatistics. Join program_variants to program_statistics on program_variants.id -> program_statistics.variant_id. Filter by program_variants fields to find specific records. Return related program_statistics records or program_statistics fields.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["program_variants.id -> program_statistics.variant_id"], "keywords": ["connection", "linked", "programstatistics", "related", "relationship", "statistics"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_statistics_for_program_variants", "doc_type": "query_recipe", "text": "Recipe: programstatistics for programvariant. Join program_statistics to program_variants on program_variants.id -> program_statistics.variant_id. Filter by program_variants fields to find specific programvariant. Return related program_statistics records.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": null, "join_hints": ["program_variants.id -> program_statistics.variant_id"], "keywords": ["associated", "belongs", "for", "programstatistics", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_variants_linked_to_program_executions", "doc_type": "query_recipe", "text": "Recipe: programvariant linked to programexecution. Join program_variants to program_executions on program_variants.id -> program_executions.variant_id. Filter by program_variants fields to find specific records. Return related program_executions records or program_executions fields.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["program_variants.id -> program_executions.variant_id"], "keywords": ["connection", "executions", "linked", "programexecution", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_executions_for_program_variants", "doc_type": "query_recipe", "text": "Recipe: programexecution for programvariant. Join program_executions to program_variants on program_variants.id -> program_executions.variant_id. Filter by program_variants fields to find specific programvariant. Return related program_executions records.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": null, "join_hints": ["program_variants.id -> program_executions.variant_id"], "keywords": ["associated", "belongs", "for", "programexecution", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:list_all_program_variants_names", "doc_type": "query_recipe", "text": "Recipe: list all programvariant names. Query program_variants table. Use SELECT name FROM program_variants. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:program_variants_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: programvariant names and descriptions. Query program_variants table. Use SELECT name, description FROM program_variants. Optionally filter by conditions if specified. Return name and description columns.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": [], "keywords": ["and", "description", "descriptions", "detail", "details", "info", "information", "label", "labels", "name", "names", "title", "titles"], "semantics": "SELECT multiple columns", "recipe_type": "generic"}}
{"id": "query_recipe:all_program_variants", "doc_type": "query_recipe", "text": "Recipe: all programvariants. Query program_variants table. Use SELECT * FROM program_variants or SELECT specific columns. Optionally filter by conditions if specified. Return all records from program_variants.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "programvariant"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.program.ProgramStatistics", "doc_type": "schema_model", "text": "Model: ProgramStatistics (table program_statistics) — Program statistics model - tracks aggregated usage and performance metrics. This model stores aggregated performance metrics and execution statistics. Key columns: program id (identifier), variant id (identifier), usage count (number of usage), success count (number of success), failure count (number of failure), updated at (timestamp when record was last updated) Commonly used for: performance metrics and analytics, aggregated execution statistics, success and failure tracking, temporal queries and filtering Example queries: 'usage count for program', 'how many usage for program', 'success count for program', 'how many success for program' Relationships: related to program via program, related to programvariant via variant", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "source_file": "backend/models/program.py"}}
{"id": "schema_column:models.program.ProgramStatistics.id", "doc_type": "schema_column", "text": "Column: ProgramStatistics.id (table program_statistics) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id"]}}
{"id": "query_recipe:program_statistics.id", "doc_type": "query_recipe", "text": "Recipe: access id from program_statistics. Filter by program_statistics.id to find specific records.. Return ProgramStatistics.id", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "id", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.program.ProgramStatistics.program_id", "doc_type": "schema_column", "text": "Column: ProgramStatistics.program_id (table program_statistics) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "program_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id", "program"]}}
{"id": "query_recipe:program_statistics.program_id", "doc_type": "query_recipe", "text": "Recipe: access program_id from program_statistics. Filter by program_statistics.program_id to find specific records.. Return ProgramStatistics.program_id", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "program_id", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["id", "program"], "semantics": null}}
{"id": "schema_column:models.program.ProgramStatistics.variant_id", "doc_type": "schema_column", "text": "Column: ProgramStatistics.variant_id (table program_statistics) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "variant_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["id", "variant"]}}
{"id": "query_recipe:program_statistics.variant_id", "doc_type": "query_recipe", "text": "Recipe: access variant_id from program_statistics. Filter by program_statistics.variant_id to find specific records.. Return ProgramStatistics.variant_id. Note: If multiple rows exist due to variants (variant_id), either sum across rows or choose variant_id IS NULL depending on requested semantics.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "variant_id", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["id", "variant"], "semantics": "variant_id handling"}}
{"id": "schema_column:models.program.ProgramStatistics.usage_count", "doc_type": "schema_column", "text": "Column: ProgramStatistics.usage_count (table program_statistics) — integer counter of usage Used to track or store number of usage. Default: 0. Common query patterns: COUNT(*) or SUM(usage_count) for aggregation, WHERE usage_count > value for filtering. Related columns: success_count, failure_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "usage_count", "type": "INTEGER", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["count", "executions", "how many", "how many times", "number", "quantity", "ran", "run", "runs", "total", "usage", "used"]}}
{"id": "query_recipe:program_statistics.usage_count", "doc_type": "query_recipe", "text": "Recipe: access usage_count from program_statistics. Return ProgramStatistics.usage_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "usage_count", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["count", "executions", "how many", "how many times", "number", "quantity", "ran", "run", "runs", "total", "usage", "used"], "semantics": null}}
{"id": "query_recipe:how_many_usage_count", "doc_type": "query_recipe", "text": "Recipe: how many usage. Query program_statistics table. Use COUNT(*) or SUM(usage_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "usage_count", "join_hints": [], "keywords": ["count", "executions", "how many", "how many times", "number", "quantity", "ran", "run", "runs", "total", "usage", "used"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramStatistics.success_count", "doc_type": "schema_column", "text": "Column: ProgramStatistics.success_count (table program_statistics) — integer counter of success Used to track or store number of success. Default: 0. Common query patterns: COUNT(*) or SUM(success_count) for aggregation, WHERE success_count > value for filtering. Related columns: usage_count, failure_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "success_count", "type": "INTEGER", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"]}}
{"id": "query_recipe:program_statistics.success_count", "doc_type": "query_recipe", "text": "Recipe: access success_count from program_statistics. Return ProgramStatistics.success_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "success_count", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"], "semantics": null}}
{"id": "query_recipe:how_many_success_count", "doc_type": "query_recipe", "text": "Recipe: how many success. Query program_statistics table. Use COUNT(*) or SUM(success_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "success_count", "join_hints": [], "keywords": ["count", "how many", "how many times", "number", "quantity", "succeeded", "success", "total", "win", "wins"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramStatistics.failure_count", "doc_type": "schema_column", "text": "Column: ProgramStatistics.failure_count (table program_statistics) — integer counter of failure Used to track or store number of failure. Default: 0. Common query patterns: COUNT(*) or SUM(failure_count) for aggregation, WHERE failure_count > value for filtering. Related columns: usage_count, success_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "failure_count", "type": "INTEGER", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"]}}
{"id": "query_recipe:program_statistics.failure_count", "doc_type": "query_recipe", "text": "Recipe: access failure_count from program_statistics. Return ProgramStatistics.failure_count", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "failure_count", "join_hints": ["program_statistics.program_id -> programs.id", "program_statistics.variant_id -> program_variants.id"], "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"], "semantics": null}}
{"id": "query_recipe:how_many_failure_count", "doc_type": "query_recipe", "text": "Recipe: how many failure. Query program_statistics table. Use COUNT(*) or SUM(failure_count) depending on semantics. Filter by appropriate conditions if specified. Return the count as a number.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "failure_count", "join_hints": [], "keywords": ["count", "error", "errors", "fail", "failed", "failure", "how many", "how many times", "number", "quantity", "total"], "semantics": "Aggregation: COUNT or SUM", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramStatistics.avg_execution_time", "doc_type": "schema_column", "text": "Column: ProgramStatistics.avg_execution_time (table program_statistics) — numeric timestamp or duration Used to track or store average execution or processing time. Common query patterns: AVG(avg_execution_time) for average calculation.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_execution_time", "type": "FLOAT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["avg", "duration", "elapsed", "execution", "runtime", "time"]}}
{"id": "query_recipe:average_avg_execution_time", "doc_type": "query_recipe", "text": "Recipe: average avg execution time. Query program_statistics table. Use AVG(avg_execution_time) to calculate average. Filter by appropriate conditions if specified. Group by relevant fields if needed. Return the average value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_execution_time", "join_hints": [], "keywords": ["average", "avg", "duration", "elapsed", "execution", "mean", "runtime", "time", "typical"], "semantics": "Aggregation: AVG", "recipe_type": "aggregation"}}
{"id": "query_recipe:maximum_avg_execution_time", "doc_type": "query_recipe", "text": "Recipe: maximum or highest avg execution time. Query program_statistics table. Use MAX(avg_execution_time) to find maximum value. Or use ORDER BY avg_execution_time DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_execution_time", "join_hints": [], "keywords": ["avg", "best", "duration", "elapsed", "execution", "highest", "max", "maximum", "most", "runtime", "time", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_avg_execution_time", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest avg execution time. Query program_statistics table. Use MIN(avg_execution_time) to find minimum value. Or use ORDER BY avg_execution_time ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_execution_time", "join_hints": [], "keywords": ["avg", "duration", "elapsed", "execution", "least", "lowest", "min", "minimum", "runtime", "smallest", "time"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramStatistics.avg_memory_usage", "doc_type": "schema_column", "text": "Column: ProgramStatistics.avg_memory_usage (table program_statistics) — numeric Used to track or store usage count or frequency. Common query patterns: AVG(avg_memory_usage) for average calculation.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_memory_usage", "type": "FLOAT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["avg", "executions", "memory", "ran", "run", "runs", "usage", "used"]}}
{"id": "query_recipe:average_avg_memory_usage", "doc_type": "query_recipe", "text": "Recipe: average avg memory usage. Query program_statistics table. Use AVG(avg_memory_usage) to calculate average. Filter by appropriate conditions if specified. Group by relevant fields if needed. Return the average value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_memory_usage", "join_hints": [], "keywords": ["average", "avg", "executions", "mean", "memory", "ran", "run", "runs", "typical", "usage", "used"], "semantics": "Aggregation: AVG", "recipe_type": "aggregation"}}
{"id": "query_recipe:maximum_avg_memory_usage", "doc_type": "query_recipe", "text": "Recipe: maximum or highest avg memory usage. Query program_statistics table. Use MAX(avg_memory_usage) to find maximum value. Or use ORDER BY avg_memory_usage DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_memory_usage", "join_hints": [], "keywords": ["avg", "best", "executions", "highest", "max", "maximum", "memory", "most", "ran", "run", "runs", "top", "usage", "used"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_avg_memory_usage", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest avg memory usage. Query program_statistics table. Use MIN(avg_memory_usage) to find minimum value. Or use ORDER BY avg_memory_usage ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_memory_usage", "join_hints": [], "keywords": ["avg", "executions", "least", "lowest", "memory", "min", "minimum", "ran", "run", "runs", "smallest", "usage", "used"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramStatistics.output_metrics", "doc_type": "schema_column", "text": "Column: ProgramStatistics.output_metrics (table program_statistics) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "output_metrics", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["metrics", "output"]}}
{"id": "schema_column:models.program.ProgramStatistics.parameter_stats", "doc_type": "schema_column", "text": "Column: ProgramStatistics.parameter_stats (table program_statistics) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "parameter_stats", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["parameter", "stats"]}}
{"id": "schema_column:models.program.ProgramStatistics.last_used_at", "doc_type": "schema_column", "text": "Column: ProgramStatistics.last_used_at (table program_statistics) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(last_used_at) = year for year filtering, WHERE last_used_at BETWEEN start AND end for date ranges.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "last_used_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "last", "used"]}}
{"id": "query_recipe:last_used_at_last_week", "doc_type": "query_recipe", "text": "Recipe: programstatistics last used at in the last week. Query program_statistics table. Filter by last_used_at >= NOW() - INTERVAL '7' DAYS or WHERE last_used_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "last_used_at", "join_hints": [], "keywords": ["at", "last", "last week", "past", "recent", "since", "used"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.program.ProgramStatistics.updated_at", "doc_type": "schema_column", "text": "Column: ProgramStatistics.updated_at (table program_statistics) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: programstatistics updated at recently. Query program_statistics table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: programstatistics updated at in the last week. Query program_statistics table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:program_statistics_linked_to_programs", "doc_type": "query_recipe", "text": "Recipe: programstatistics linked to program. Join program_statistics to programs on program_statistics.program_id -> programs.id. Filter by program_statistics fields to find specific records. Return related programs records or programs fields.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": null, "join_hints": ["program_statistics.program_id -> programs.id"], "keywords": ["connection", "linked", "program", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:programs_for_program_statistics", "doc_type": "query_recipe", "text": "Recipe: program for programstatistics. Join programs to program_statistics on program_statistics.program_id -> programs.id. Filter by program_statistics fields to find specific programstatistics. Return related programs records.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["program_statistics.program_id -> programs.id"], "keywords": ["associated", "belongs", "for", "program", "programstatistics"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_statistics_linked_to_program_variants", "doc_type": "query_recipe", "text": "Recipe: programstatistics linked to programvariant. Join program_statistics to program_variants on program_statistics.variant_id -> program_variants.id. Filter by program_statistics fields to find specific records. Return related program_variants records or program_variants fields.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": null, "join_hints": ["program_statistics.variant_id -> program_variants.id"], "keywords": ["connection", "linked", "programvariant", "related", "relationship", "variant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_variants_for_program_statistics", "doc_type": "query_recipe", "text": "Recipe: programvariant for programstatistics. Join program_variants to program_statistics on program_statistics.variant_id -> program_variants.id. Filter by program_statistics fields to find specific programstatistics. Return related program_variants records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["program_statistics.variant_id -> program_variants.id"], "keywords": ["associated", "belongs", "for", "programstatistics", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_program_statistics", "doc_type": "query_recipe", "text": "Recipe: all programstatisticss. Query program_statistics table. Use SELECT * FROM program_statistics or SELECT specific columns. Optionally filter by conditions if specified. Return all records from program_statistics.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "programstatistics"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.program.ProgramExecution", "doc_type": "schema_model", "text": "Model: ProgramExecution (table program_executions) — Program execution model - records individual program execution instances. This model represents executable simulation programs and their metadata. Key columns: program id (identifier), variant id (identifier), simulation id (identifier) Commonly used for: program definitions and metadata Example queries: 'programexecution information', 'programexecution details' Relationships: related to program via program, related to programvariant via variant", "metadata": {"model": "ProgramExecution", "table": "program_executions", "source_file": "backend/models/program.py"}}
{"id": "schema_column:models.program.ProgramExecution.id", "doc_type": "schema_column", "text": "Column: ProgramExecution.id (table program_executions) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id"]}}
{"id": "query_recipe:program_executions.id", "doc_type": "query_recipe", "text": "Recipe: access id from program_executions. Filter by program_executions.id to find specific records.. Return ProgramExecution.id", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "id", "join_hints": ["program_executions.program_id -> programs.id", "program_executions.variant_id -> program_variants.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.program.ProgramExecution.program_id", "doc_type": "schema_column", "text": "Column: ProgramExecution.program_id (table program_executions) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "program_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/program.py", "keywords": ["id", "program"]}}
{"id": "query_recipe:program_executions.program_id", "doc_type": "query_recipe", "text": "Recipe: access program_id from program_executions. Filter by program_executions.program_id to find specific records.. Return ProgramExecution.program_id", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "program_id", "join_hints": ["program_executions.program_id -> programs.id", "program_executions.variant_id -> program_variants.id"], "keywords": ["id", "program"], "semantics": null}}
{"id": "schema_column:models.program.ProgramExecution.variant_id", "doc_type": "schema_column", "text": "Column: ProgramExecution.variant_id (table program_executions) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "variant_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["id", "variant"]}}
{"id": "query_recipe:program_executions.variant_id", "doc_type": "query_recipe", "text": "Recipe: access variant_id from program_executions. Filter by program_executions.variant_id to find specific records.. Return ProgramExecution.variant_id", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "variant_id", "join_hints": ["program_executions.program_id -> programs.id", "program_executions.variant_id -> program_variants.id"], "keywords": ["id", "variant"], "semantics": "variant_id handling"}}
{"id": "schema_column:models.program.ProgramExecution.simulation_id", "doc_type": "schema_column", "text": "Column: ProgramExecution.simulation_id (table program_executions) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "simulation_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:program_executions.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from program_executions. Filter by program_executions.simulation_id to find specific records.. Return ProgramExecution.simulation_id", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "simulation_id", "join_hints": ["program_executions.program_id -> programs.id", "program_executions.variant_id -> program_variants.id"], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.program.ProgramExecution.parameters", "doc_type": "schema_column", "text": "Column: ProgramExecution.parameters (table program_executions) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "parameters", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["parameters"]}}
{"id": "schema_column:models.program.ProgramExecution.execution_time", "doc_type": "schema_column", "text": "Column: ProgramExecution.execution_time (table program_executions) — numeric timestamp or duration Used to track or store timestamp or duration. Common query patterns: MAX(execution_time) or MIN(execution_time) for min/max, WHERE execution_time > value for numeric filtering.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "execution_time", "type": "FLOAT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["duration", "elapsed", "execution", "runtime", "time"]}}
{"id": "query_recipe:maximum_execution_time", "doc_type": "query_recipe", "text": "Recipe: maximum or highest execution time. Query program_executions table. Use MAX(execution_time) to find maximum value. Or use ORDER BY execution_time DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "execution_time", "join_hints": [], "keywords": ["best", "duration", "elapsed", "execution", "highest", "max", "maximum", "most", "runtime", "time", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_execution_time", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest execution time. Query program_executions table. Use MIN(execution_time) to find minimum value. Or use ORDER BY execution_time ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "execution_time", "join_hints": [], "keywords": ["duration", "elapsed", "execution", "least", "lowest", "min", "minimum", "runtime", "smallest", "time"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramExecution.memory_usage", "doc_type": "schema_column", "text": "Column: ProgramExecution.memory_usage (table program_executions) — numeric Used to track or store usage count or frequency. Common query patterns: MAX(memory_usage) or MIN(memory_usage) for min/max, WHERE memory_usage > value for numeric filtering.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "memory_usage", "type": "FLOAT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["executions", "memory", "ran", "run", "runs", "usage", "used"]}}
{"id": "query_recipe:maximum_memory_usage", "doc_type": "query_recipe", "text": "Recipe: maximum or highest memory usage. Query program_executions table. Use MAX(memory_usage) to find maximum value. Or use ORDER BY memory_usage DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "memory_usage", "join_hints": [], "keywords": ["best", "executions", "highest", "max", "maximum", "memory", "most", "ran", "run", "runs", "top", "usage", "used"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_memory_usage", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest memory usage. Query program_executions table. Use MIN(memory_usage) to find minimum value. Or use ORDER BY memory_usage ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "memory_usage", "join_hints": [], "keywords": ["executions", "least", "lowest", "memory", "min", "minimum", "ran", "run", "runs", "smallest", "usage", "used"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramExecution.success", "doc_type": "schema_column", "text": "Column: ProgramExecution.success (table program_executions) — integer Used to track or store number of successful operations. Default: 1. Common query patterns: MAX(success) or MIN(success) for min/max, WHERE success > value for numeric filtering.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "success", "type": "INTEGER", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["succeeded", "success", "win", "wins"]}}
{"id": "query_recipe:maximum_success", "doc_type": "query_recipe", "text": "Recipe: maximum or highest success. Query program_executions table. Use MAX(success) to find maximum value. Or use ORDER BY success DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "success", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "succeeded", "success", "top", "win", "wins"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_success", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest success. Query program_executions table. Use MIN(success) to find minimum value. Or use ORDER BY success ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "success", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "smallest", "succeeded", "success", "win", "wins"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.program.ProgramExecution.error_message", "doc_type": "schema_column", "text": "Column: ProgramExecution.error_message (table program_executions) — text Used to track or store data field.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "error_message", "type": "TEXT", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["error", "message"]}}
{"id": "schema_column:models.program.ProgramExecution.output_data", "doc_type": "schema_column", "text": "Column: ProgramExecution.output_data (table program_executions) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "output_data", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["data", "output"]}}
{"id": "schema_column:models.program.ProgramExecution.post_processed_output", "doc_type": "schema_column", "text": "Column: ProgramExecution.post_processed_output (table program_executions) — JSON object Used to track or store data field.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "post_processed_output", "type": "JSON", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["output", "post", "processed"]}}
{"id": "schema_column:models.program.ProgramExecution.executed_at", "doc_type": "schema_column", "text": "Column: ProgramExecution.executed_at (table program_executions) — datetime Used to track or store data field. Default: function utc_now. Common query patterns: WHERE YEAR(executed_at) = year for year filtering, WHERE executed_at BETWEEN start AND end for date ranges.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "executed_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/program.py", "keywords": ["at", "executed"]}}
{"id": "query_recipe:executed_at_last_week", "doc_type": "query_recipe", "text": "Recipe: programexecution executed at in the last week. Query program_executions table. Filter by executed_at >= NOW() - INTERVAL '7' DAYS or WHERE executed_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "executed_at", "join_hints": [], "keywords": ["at", "executed", "last week", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:program_executions_linked_to_programs", "doc_type": "query_recipe", "text": "Recipe: programexecution linked to program. Join program_executions to programs on program_executions.program_id -> programs.id. Filter by program_executions fields to find specific records. Return related programs records or programs fields.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": null, "join_hints": ["program_executions.program_id -> programs.id"], "keywords": ["connection", "linked", "program", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:programs_for_program_executions", "doc_type": "query_recipe", "text": "Recipe: program for programexecution. Join programs to program_executions on program_executions.program_id -> programs.id. Filter by program_executions fields to find specific programexecution. Return related programs records.", "metadata": {"model": "Program", "table": "programs", "column": null, "join_hints": ["program_executions.program_id -> programs.id"], "keywords": ["associated", "belongs", "for", "program", "programexecution"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_executions_linked_to_program_variants", "doc_type": "query_recipe", "text": "Recipe: programexecution linked to programvariant. Join program_executions to program_variants on program_executions.variant_id -> program_variants.id. Filter by program_executions fields to find specific records. Return related program_variants records or program_variants fields.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": null, "join_hints": ["program_executions.variant_id -> program_variants.id"], "keywords": ["connection", "linked", "programvariant", "related", "relationship", "variant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:program_variants_for_program_executions", "doc_type": "query_recipe", "text": "Recipe: programvariant for programexecution. Join program_variants to program_executions on program_executions.variant_id -> program_variants.id. Filter by program_executions fields to find specific programexecution. Return related program_variants records.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": null, "join_hints": ["program_executions.variant_id -> program_variants.id"], "keywords": ["associated", "belongs", "for", "programexecution", "programvariant"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_program_executions", "doc_type": "query_recipe", "text": "Recipe: all programexecutions. Query program_executions table. Use SELECT * FROM program_executions or SELECT specific columns. Optionally filter by conditions if specified. Return all records from program_executions.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "programexecution"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.metric_definition.MetricDefinition", "doc_type": "schema_model", "text": "Model: MetricDefinition (table metric_definitions) — Metric definition record. Key columns: created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: temporal queries and filtering Relationships: related to metrictag via tag_objects", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "source_file": "backend/models/metric_definition.py"}}
{"id": "schema_column:models.metric_definition.MetricDefinition.id", "doc_type": "schema_column", "text": "Column: MetricDefinition.id (table metric_definitions) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["id"]}}
{"id": "query_recipe:metric_definitions.id", "doc_type": "query_recipe", "text": "Recipe: access id from metric_definitions. Filter by metric_definitions.id to find specific records.. Return MetricDefinition.id", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "id", "join_hints": ["metric_definitions.id -> metric_definition_tags.metric_definition_id", "metric_definitions.id -> metric_definition_tags.tag_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.metric_definition.MetricDefinition.key", "doc_type": "schema_column", "text": "Column: MetricDefinition.key (table metric_definitions) — varchar Used to track or store data field. Required field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "key", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["key"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.label", "doc_type": "schema_column", "text": "Column: MetricDefinition.label (table metric_definitions) — varchar Used to track or store data field. Required field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "label", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["label"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.description", "doc_type": "schema_column", "text": "Column: MetricDefinition.description (table metric_definitions) — text descriptive text Used to track or store descriptive text or details.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "description", "type": "TEXT", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["description", "descriptions", "detail", "details", "info", "information"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.category", "doc_type": "schema_column", "text": "Column: MetricDefinition.category (table metric_definitions) — varchar Used to track or store data field. Required field. Default: custom.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "category", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["category"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.format", "doc_type": "schema_column", "text": "Column: MetricDefinition.format (table metric_definitions) — varchar Used to track or store data field. Required field. Default: number.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "format", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["format"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.color_scheme", "doc_type": "schema_column", "text": "Column: MetricDefinition.color_scheme (table metric_definitions) — varchar Used to track or store data field. Required field. Default: blue.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "color_scheme", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["color", "scheme"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.unit", "doc_type": "schema_column", "text": "Column: MetricDefinition.unit (table metric_definitions) — varchar Used to track or store data field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "unit", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["unit"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.icon", "doc_type": "schema_column", "text": "Column: MetricDefinition.icon (table metric_definitions) — varchar Used to track or store data field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "icon", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["icon"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.priority", "doc_type": "schema_column", "text": "Column: MetricDefinition.priority (table metric_definitions) — integer Used to track or store data field. Required field. Default: 0. Common query patterns: MAX(priority) or MIN(priority) for min/max, WHERE priority > value for numeric filtering.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "priority", "type": "INTEGER", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["priority"]}}
{"id": "query_recipe:maximum_priority", "doc_type": "query_recipe", "text": "Recipe: maximum or highest priority. Query metric_definitions table. Use MAX(priority) to find maximum value. Or use ORDER BY priority DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "priority", "join_hints": [], "keywords": ["best", "highest", "max", "maximum", "most", "priority", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_priority", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest priority. Query metric_definitions table. Use MIN(priority) to find minimum value. Or use ORDER BY priority ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "priority", "join_hints": [], "keywords": ["least", "lowest", "min", "minimum", "priority", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.metric_definition.MetricDefinition.tags", "doc_type": "schema_column", "text": "Column: MetricDefinition.tags (table metric_definitions) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "tags", "type": "JSON", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["tags"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.threshold", "doc_type": "schema_column", "text": "Column: MetricDefinition.threshold (table metric_definitions) — JSON object Used to track or store data field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "threshold", "type": "JSON", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["threshold"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.compute_spec", "doc_type": "schema_column", "text": "Column: MetricDefinition.compute_spec (table metric_definitions) — JSON object Used to track or store data field.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "compute_spec", "type": "JSON", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["compute", "spec"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.is_chart", "doc_type": "schema_column", "text": "Column: MetricDefinition.is_chart (table metric_definitions) — boolean Used to track or store data field. Required field. Default: False.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "is_chart", "type": "BOOLEAN", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["chart", "is"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.is_active", "doc_type": "schema_column", "text": "Column: MetricDefinition.is_active (table metric_definitions) — boolean Used to track or store data field. Required field. Default: True.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "is_active", "type": "BOOLEAN", "nullable": false, "source_file": "backend/models/metric_definition.py", "keywords": ["active", "is"]}}
{"id": "schema_column:models.metric_definition.MetricDefinition.created_at", "doc_type": "schema_column", "text": "Column: MetricDefinition.created_at (table metric_definitions) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: metricdefinition created at in specific year or date range. Query metric_definitions table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: metricdefinition created at in the last week. Query metric_definitions table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.metric_definition.MetricDefinition.updated_at", "doc_type": "schema_column", "text": "Column: MetricDefinition.updated_at (table metric_definitions) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/metric_definition.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: metricdefinition updated at recently. Query metric_definitions table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: metricdefinition updated at in the last week. Query metric_definitions table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:metric_definitions_linked_to_metric_tags", "doc_type": "query_recipe", "text": "Recipe: metricdefinition linked to metrictag. Join metric_definitions to metric_tags on metric_definitions.id -> metric_definition_tags.metric_definition_id. Filter by metric_definitions fields to find specific records. Return related metric_tags records or metric_tags fields.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": null, "join_hints": ["metric_definitions.id -> metric_definition_tags.metric_definition_id", "metric_definitions.id -> metric_definition_tags.tag_id"], "keywords": ["connection", "linked", "metrictag", "objects", "related", "relationship", "tag"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:metric_tags_for_metric_definitions", "doc_type": "query_recipe", "text": "Recipe: metrictag for metricdefinition. Join metric_tags to metric_definitions on metric_definitions.id -> metric_definition_tags.metric_definition_id. Filter by metric_definitions fields to find specific metricdefinition. Return related metric_tags records.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": null, "join_hints": ["metric_definitions.id -> metric_definition_tags.metric_definition_id", "metric_definitions.id -> metric_definition_tags.tag_id"], "keywords": ["associated", "belongs", "for", "metricdefinition", "metrictag"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_metric_definitions", "doc_type": "query_recipe", "text": "Recipe: all metricdefinitions. Query metric_definitions table. Use SELECT * FROM metric_definitions or SELECT specific columns. Optionally filter by conditions if specified. Return all records from metric_definitions.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "metricdefinition"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.metric_tag.MetricTag", "doc_type": "schema_model", "text": "Model: MetricTag (table metric_tags) — Tag record for metric definitions. Key columns: name (name or label for identification) Example queries: 'metrictag names' Relationships: related to metricdefinition via metrics", "metadata": {"model": "MetricTag", "table": "metric_tags", "source_file": "backend/models/metric_tag.py"}}
{"id": "schema_column:models.metric_tag.MetricTag.id", "doc_type": "schema_column", "text": "Column: MetricTag.id (table metric_tags) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_tag.py", "keywords": ["id"]}}
{"id": "query_recipe:metric_tags.id", "doc_type": "query_recipe", "text": "Recipe: access id from metric_tags. Filter by metric_tags.id to find specific records.. Return MetricTag.id", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": "id", "join_hints": ["metric_tags.id -> metric_definition_tags.tag_id", "metric_tags.id -> metric_definition_tags.metric_definition_id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.metric_tag.MetricTag.name", "doc_type": "schema_column", "text": "Column: MetricTag.name (table metric_tags) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE name = 'value' for exact match, WHERE name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": "name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/metric_tag.py", "keywords": ["label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:metric_tags.name", "doc_type": "query_recipe", "text": "Recipe: access name from metric_tags. Filter by metric_tags.name to find specific records.. Return MetricTag.name", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": "name", "join_hints": ["metric_tags.id -> metric_definition_tags.tag_id", "metric_tags.id -> metric_definition_tags.metric_definition_id"], "keywords": ["label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "query_recipe:metric_tags_linked_to_metric_definitions", "doc_type": "query_recipe", "text": "Recipe: metrictag linked to metricdefinition. Join metric_tags to metric_definitions on metric_tags.id -> metric_definition_tags.tag_id. Filter by metric_tags fields to find specific records. Return related metric_definitions records or metric_definitions fields.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": null, "join_hints": ["metric_tags.id -> metric_definition_tags.tag_id", "metric_tags.id -> metric_definition_tags.metric_definition_id"], "keywords": ["connection", "linked", "metricdefinition", "metrics", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:metric_definitions_for_metric_tags", "doc_type": "query_recipe", "text": "Recipe: metricdefinition for metrictag. Join metric_definitions to metric_tags on metric_tags.id -> metric_definition_tags.tag_id. Filter by metric_tags fields to find specific metrictag. Return related metric_definitions records.", "metadata": {"model": "MetricDefinition", "table": "metric_definitions", "column": null, "join_hints": ["metric_tags.id -> metric_definition_tags.tag_id", "metric_tags.id -> metric_definition_tags.metric_definition_id"], "keywords": ["associated", "belongs", "for", "metricdefinition", "metrictag"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:list_all_metric_tags_names", "doc_type": "query_recipe", "text": "Recipe: list all metrictag names. Query metric_tags table. Use SELECT name FROM metric_tags. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all name values.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": "name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:all_metric_tags", "doc_type": "query_recipe", "text": "Recipe: all metrictags. Query metric_tags table. Use SELECT * FROM metric_tags or SELECT specific columns. Optionally filter by conditions if specified. Return all records from metric_tags.", "metadata": {"model": "MetricTag", "table": "metric_tags", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "metrictag"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.note.Note", "doc_type": "schema_model", "text": "Model: Note (table notes) — A minimal user-scoped note with optional research/experiment context. Key columns: session id (identifier), research id (identifier), experiment id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: temporal queries and filtering Relationships: related to research via research, related to experiment via experiment", "metadata": {"model": "Note", "table": "notes", "source_file": "backend/models/note.py"}}
{"id": "schema_column:models.note.Note.id", "doc_type": "schema_column", "text": "Column: Note.id (table notes) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "Note", "table": "notes", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/note.py", "keywords": ["id"]}}
{"id": "query_recipe:notes.id", "doc_type": "query_recipe", "text": "Recipe: access id from notes. Filter by notes.id to find specific records.. Return Note.id", "metadata": {"model": "Note", "table": "notes", "column": "id", "join_hints": ["notes.research_id -> research.id", "notes.experiment_id -> experiments.id"], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.note.Note.session_id", "doc_type": "schema_column", "text": "Column: Note.session_id (table notes) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "Note", "table": "notes", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/note.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:notes.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from notes. Filter by notes.session_id to find specific records.. Return Note.session_id", "metadata": {"model": "Note", "table": "notes", "column": "session_id", "join_hints": ["notes.research_id -> research.id", "notes.experiment_id -> experiments.id"], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.note.Note.content", "doc_type": "schema_column", "text": "Column: Note.content (table notes) — text Used to track or store data field. Required field.", "metadata": {"model": "Note", "table": "notes", "column": "content", "type": "TEXT", "nullable": false, "source_file": "backend/models/note.py", "keywords": ["content"]}}
{"id": "schema_column:models.note.Note.research_id", "doc_type": "schema_column", "text": "Column: Note.research_id (table notes) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "Note", "table": "notes", "column": "research_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/note.py", "keywords": ["id", "research"]}}
{"id": "query_recipe:notes.research_id", "doc_type": "query_recipe", "text": "Recipe: access research_id from notes. Filter by notes.research_id to find specific records.. Return Note.research_id", "metadata": {"model": "Note", "table": "notes", "column": "research_id", "join_hints": ["notes.research_id -> research.id", "notes.experiment_id -> experiments.id"], "keywords": ["id", "research"], "semantics": null}}
{"id": "schema_column:models.note.Note.experiment_id", "doc_type": "schema_column", "text": "Column: Note.experiment_id (table notes) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "Note", "table": "notes", "column": "experiment_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/note.py", "keywords": ["experiment", "id"]}}
{"id": "query_recipe:notes.experiment_id", "doc_type": "query_recipe", "text": "Recipe: access experiment_id from notes. Filter by notes.experiment_id to find specific records.. Return Note.experiment_id", "metadata": {"model": "Note", "table": "notes", "column": "experiment_id", "join_hints": ["notes.research_id -> research.id", "notes.experiment_id -> experiments.id"], "keywords": ["experiment", "id"], "semantics": null}}
{"id": "schema_column:models.note.Note.created_at", "doc_type": "schema_column", "text": "Column: Note.created_at (table notes) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "Note", "table": "notes", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/note.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: note created at in specific year or date range. Query notes table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "Note", "table": "notes", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: note created at in the last week. Query notes table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Note", "table": "notes", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.note.Note.updated_at", "doc_type": "schema_column", "text": "Column: Note.updated_at (table notes) — datetime Used to track or store timestamp when record was last updated. Required field. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "Note", "table": "notes", "column": "updated_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/note.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: note updated at recently. Query notes table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "Note", "table": "notes", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: note updated at in the last week. Query notes table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "Note", "table": "notes", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:notes_linked_to_research", "doc_type": "query_recipe", "text": "Recipe: note linked to research. Join notes to research on notes.research_id -> research.id. Filter by notes fields to find specific records. Return related research records or research fields.", "metadata": {"model": "Note", "table": "notes", "column": null, "join_hints": ["notes.research_id -> research.id"], "keywords": ["connection", "linked", "related", "relationship", "research"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:research_for_notes", "doc_type": "query_recipe", "text": "Recipe: research for note. Join research to notes on notes.research_id -> research.id. Filter by notes fields to find specific note. Return related research records.", "metadata": {"model": "Research", "table": "research", "column": null, "join_hints": ["notes.research_id -> research.id"], "keywords": ["associated", "belongs", "for", "note", "research"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:notes_linked_to_experiments", "doc_type": "query_recipe", "text": "Recipe: note linked to experiment. Join notes to experiments on notes.experiment_id -> experiments.id. Filter by notes fields to find specific records. Return related experiments records or experiments fields.", "metadata": {"model": "Note", "table": "notes", "column": null, "join_hints": ["notes.experiment_id -> experiments.id"], "keywords": ["connection", "experiment", "linked", "related", "relationship"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:experiments_for_notes", "doc_type": "query_recipe", "text": "Recipe: experiment for note. Join experiments to notes on notes.experiment_id -> experiments.id. Filter by notes fields to find specific note. Return related experiments records.", "metadata": {"model": "Experiment", "table": "experiments", "column": null, "join_hints": ["notes.experiment_id -> experiments.id"], "keywords": ["associated", "belongs", "experiment", "for", "note"], "semantics": null, "recipe_type": "relationship"}}
{"id": "query_recipe:all_notes", "doc_type": "query_recipe", "text": "Recipe: all notes. Query notes table. Use SELECT * FROM notes or SELECT specific columns. Optionally filter by conditions if specified. Return all records from notes.", "metadata": {"model": "Note", "table": "notes", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "note"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.tool_telemetry.ToolTelemetryEvent", "doc_type": "schema_model", "text": "Model: ToolTelemetryEvent (table tool_telemetry_events) — Tool telemetry event model - tracks tool invocations for metrics. Key columns: tool name (name or label for identification), simulation id (identifier), experiment id (identifier), session id (identifier), created at (timestamp when record was created) Commonly used for: temporal queries and filtering Example queries: 'tooltelemetryevent names'", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "source_file": "backend/models/tool_telemetry.py"}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.id", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.id (table tool_telemetry_events) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/tool_telemetry.py", "keywords": ["id"]}}
{"id": "query_recipe:tool_telemetry_events.id", "doc_type": "query_recipe", "text": "Recipe: access id from tool_telemetry_events. Filter by tool_telemetry_events.id to find specific records.. Return ToolTelemetryEvent.id", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.tool_name", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.tool_name (table tool_telemetry_events) — varchar name or label Used to track or store name or label for identification. Required field. Common query patterns: WHERE tool_name = 'value' for exact match, WHERE tool_name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "tool_name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/tool_telemetry.py", "keywords": ["label", "labels", "name", "names", "title", "titles", "tool"]}}
{"id": "query_recipe:tool_telemetry_events.tool_name", "doc_type": "query_recipe", "text": "Recipe: access tool_name from tool_telemetry_events. Filter by tool_telemetry_events.tool_name to find specific records.. Return ToolTelemetryEvent.tool_name", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "tool_name", "join_hints": [], "keywords": ["label", "labels", "name", "names", "title", "titles", "tool"], "semantics": null}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.simulation_id", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.simulation_id (table tool_telemetry_events) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "simulation_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["id", "simulation"]}}
{"id": "query_recipe:tool_telemetry_events.simulation_id", "doc_type": "query_recipe", "text": "Recipe: access simulation_id from tool_telemetry_events. Filter by tool_telemetry_events.simulation_id to find specific records.. Return ToolTelemetryEvent.simulation_id", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "simulation_id", "join_hints": [], "keywords": ["id", "simulation"], "semantics": null}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.experiment_id", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.experiment_id (table tool_telemetry_events) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "experiment_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["experiment", "id"]}}
{"id": "query_recipe:tool_telemetry_events.experiment_id", "doc_type": "query_recipe", "text": "Recipe: access experiment_id from tool_telemetry_events. Filter by tool_telemetry_events.experiment_id to find specific records.. Return ToolTelemetryEvent.experiment_id", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "experiment_id", "join_hints": [], "keywords": ["experiment", "id"], "semantics": null}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.session_id", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.session_id (table tool_telemetry_events) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "session_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:tool_telemetry_events.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from tool_telemetry_events. Filter by tool_telemetry_events.session_id to find specific records.. Return ToolTelemetryEvent.session_id", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.start_timestamp", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.start_timestamp (table tool_telemetry_events) — datetime timestamp or duration Used to track or store timestamp or duration. Required field. Common query patterns: WHERE YEAR(start_timestamp) = year for year filtering, WHERE start_timestamp BETWEEN start AND end for date ranges.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "start_timestamp", "type": "DATETIME", "nullable": false, "source_file": "backend/models/tool_telemetry.py", "keywords": ["duration", "elapsed", "runtime", "start", "time", "timestamp"]}}
{"id": "query_recipe:start_timestamp_last_week", "doc_type": "query_recipe", "text": "Recipe: tooltelemetryevent start timestamp in the last week. Query tool_telemetry_events table. Filter by start_timestamp >= NOW() - INTERVAL '7' DAYS or WHERE start_timestamp >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "start_timestamp", "join_hints": [], "keywords": ["duration", "elapsed", "last week", "past", "recent", "runtime", "since", "start", "time", "timestamp"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.end_timestamp", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.end_timestamp (table tool_telemetry_events) — datetime timestamp or duration Used to track or store timestamp or duration. Common query patterns: WHERE YEAR(end_timestamp) = year for year filtering, WHERE end_timestamp BETWEEN start AND end for date ranges.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "end_timestamp", "type": "DATETIME", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["duration", "elapsed", "end", "runtime", "time", "timestamp"]}}
{"id": "query_recipe:end_timestamp_last_week", "doc_type": "query_recipe", "text": "Recipe: tooltelemetryevent end timestamp in the last week. Query tool_telemetry_events table. Filter by end_timestamp >= NOW() - INTERVAL '7' DAYS or WHERE end_timestamp >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "end_timestamp", "join_hints": [], "keywords": ["duration", "elapsed", "end", "last week", "past", "recent", "runtime", "since", "time", "timestamp"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.duration_ms", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.duration_ms (table tool_telemetry_events) — numeric Used to track or store data field. Common query patterns: MAX(duration_ms) or MIN(duration_ms) for min/max, WHERE duration_ms > value for numeric filtering.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "duration_ms", "type": "FLOAT", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["duration", "ms"]}}
{"id": "query_recipe:maximum_duration_ms", "doc_type": "query_recipe", "text": "Recipe: maximum or highest duration ms. Query tool_telemetry_events table. Use MAX(duration_ms) to find maximum value. Or use ORDER BY duration_ms DESC LIMIT 1 to find record with highest value. Filter by appropriate conditions if specified. Return the maximum value or the record with maximum value.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "duration_ms", "join_hints": [], "keywords": ["best", "duration", "highest", "max", "maximum", "most", "ms", "top"], "semantics": "Aggregation: MAX", "recipe_type": "aggregation"}}
{"id": "query_recipe:minimum_duration_ms", "doc_type": "query_recipe", "text": "Recipe: minimum or lowest duration ms. Query tool_telemetry_events table. Use MIN(duration_ms) to find minimum value. Or use ORDER BY duration_ms ASC LIMIT 1 to find record with lowest value. Filter by appropriate conditions if specified. Return the minimum value or the record with minimum value.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "duration_ms", "join_hints": [], "keywords": ["duration", "least", "lowest", "min", "minimum", "ms", "smallest"], "semantics": "Aggregation: MIN", "recipe_type": "aggregation"}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.success", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.success (table tool_telemetry_events) — varchar Used to track or store number of successful operations. Required field.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "success", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/tool_telemetry.py", "keywords": ["succeeded", "success", "win", "wins"]}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.error_message", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.error_message (table tool_telemetry_events) — text Used to track or store data field.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "error_message", "type": "TEXT", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["error", "message"]}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.metadata", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.metadata (table tool_telemetry_events) — JSON object Used to track or store data field.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "metadata", "type": "JSON", "nullable": true, "source_file": "backend/models/tool_telemetry.py", "keywords": ["metadata"]}}
{"id": "schema_column:models.tool_telemetry.ToolTelemetryEvent.created_at", "doc_type": "schema_column", "text": "Column: ToolTelemetryEvent.created_at (table tool_telemetry_events) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/tool_telemetry.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: tooltelemetryevent created at in specific year or date range. Query tool_telemetry_events table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: tooltelemetryevent created at in the last week. Query tool_telemetry_events table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:list_all_tool_telemetry_events_names", "doc_type": "query_recipe", "text": "Recipe: list all tooltelemetryevent names. Query tool_telemetry_events table. Use SELECT tool_name FROM tool_telemetry_events. Optionally filter by conditions if specified. Order by tool_name ASC for alphabetical order. Return all tool_name values.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": "tool_name", "join_hints": [], "keywords": ["all", "label", "labels", "list", "list all", "name", "names", "title", "titles", "tool"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:all_tool_telemetry_events", "doc_type": "query_recipe", "text": "Recipe: all tooltelemetryevents. Query tool_telemetry_events table. Use SELECT * FROM tool_telemetry_events or SELECT specific columns. Optionally filter by conditions if specified. Return all records from tool_telemetry_events.", "metadata": {"model": "ToolTelemetryEvent", "table": "tool_telemetry_events", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "tooltelemetryevent"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.user_research_event.UserResearchEvent", "doc_type": "schema_model", "text": "Model: UserResearchEvent (table user_research_events) — Individual event in the local user's research history timeline. This model stores research goals, questions, and related information. Key columns: session id (identifier), entity id (identifier), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: research goals and questions, temporal queries and filtering Example queries: 'userresearchevent goals', 'userresearchevent questions'", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "source_file": "backend/models/user_research_event.py"}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.id", "doc_type": "schema_column", "text": "Column: UserResearchEvent.id (table user_research_events) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["id"]}}
{"id": "query_recipe:user_research_events.id", "doc_type": "query_recipe", "text": "Recipe: access id from user_research_events. Filter by user_research_events.id to find specific records.. Return UserResearchEvent.id", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.session_id", "doc_type": "schema_column", "text": "Column: UserResearchEvent.session_id (table user_research_events) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "session_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["id", "session"]}}
{"id": "query_recipe:user_research_events.session_id", "doc_type": "query_recipe", "text": "Recipe: access session_id from user_research_events. Filter by user_research_events.session_id to find specific records.. Return UserResearchEvent.session_id", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "session_id", "join_hints": [], "keywords": ["id", "session"], "semantics": null}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.event_type", "doc_type": "schema_column", "text": "Column: UserResearchEvent.event_type (table user_research_events) — varchar(128) Used to track or store data field. Required field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "event_type", "type": "VARCHAR(128)", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["event", "type"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.category", "doc_type": "schema_column", "text": "Column: UserResearchEvent.category (table user_research_events) — varchar(64) Used to track or store data field. Required field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "category", "type": "VARCHAR(64)", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["category"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.title", "doc_type": "schema_column", "text": "Column: UserResearchEvent.title (table user_research_events) — varchar Used to track or store data field. Required field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "title", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["title"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.body", "doc_type": "schema_column", "text": "Column: UserResearchEvent.body (table user_research_events) — text Used to track or store data field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "body", "type": "TEXT", "nullable": true, "source_file": "backend/models/user_research_event.py", "keywords": ["body"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.entity_type", "doc_type": "schema_column", "text": "Column: UserResearchEvent.entity_type (table user_research_events) — varchar Used to track or store data field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "entity_type", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_event.py", "keywords": ["entity", "type"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.entity_id", "doc_type": "schema_column", "text": "Column: UserResearchEvent.entity_id (table user_research_events) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "entity_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_event.py", "keywords": ["entity", "id"]}}
{"id": "query_recipe:user_research_events.entity_id", "doc_type": "query_recipe", "text": "Recipe: access entity_id from user_research_events. Filter by user_research_events.entity_id to find specific records.. Return UserResearchEvent.entity_id", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "entity_id", "join_hints": [], "keywords": ["entity", "id"], "semantics": null}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.importance", "doc_type": "schema_column", "text": "Column: UserResearchEvent.importance (table user_research_events) — varchar Used to track or store data field. Required field. Default: info.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "importance", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["importance"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.tags", "doc_type": "schema_column", "text": "Column: UserResearchEvent.tags (table user_research_events) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "tags", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["tags"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.metadata", "doc_type": "schema_column", "text": "Column: UserResearchEvent.metadata (table user_research_events) — JSON object Used to track or store data field. Required field. Default: function dict.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "metadata", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["metadata"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.occurred_at", "doc_type": "schema_column", "text": "Column: UserResearchEvent.occurred_at (table user_research_events) — datetime Used to track or store data field. Required field. Default: function utc_now. Common query patterns: WHERE YEAR(occurred_at) = year for year filtering, WHERE occurred_at BETWEEN start AND end for date ranges.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "occurred_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["at", "occurred"]}}
{"id": "query_recipe:occurred_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchevent occurred at in the last week. Query user_research_events table. Filter by occurred_at >= NOW() - INTERVAL '7' DAYS or WHERE occurred_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "occurred_at", "join_hints": [], "keywords": ["at", "last week", "occurred", "past", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.pinned_at", "doc_type": "schema_column", "text": "Column: UserResearchEvent.pinned_at (table user_research_events) — datetime Used to track or store data field. Common query patterns: WHERE YEAR(pinned_at) = year for year filtering, WHERE pinned_at BETWEEN start AND end for date ranges.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "pinned_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/user_research_event.py", "keywords": ["at", "pinned"]}}
{"id": "query_recipe:pinned_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchevent pinned at in the last week. Query user_research_events table. Filter by pinned_at >= NOW() - INTERVAL '7' DAYS or WHERE pinned_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "pinned_at", "join_hints": [], "keywords": ["at", "last week", "past", "pinned", "recent", "since"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.is_system_generated", "doc_type": "schema_column", "text": "Column: UserResearchEvent.is_system_generated (table user_research_events) — boolean Used to track or store data field. Required field. Default: True.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "is_system_generated", "type": "BOOLEAN", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["generated", "is", "system"]}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.idempotency_key", "doc_type": "schema_column", "text": "Column: UserResearchEvent.idempotency_key (table user_research_events) — varchar Used to track or store data field.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "idempotency_key", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_event.py", "keywords": ["idempotency", "key"]}}
{"id": "query_recipe:user_research_events.idempotency_key", "doc_type": "query_recipe", "text": "Recipe: access idempotency_key from user_research_events. Filter by user_research_events.idempotency_key to find specific records.. Return UserResearchEvent.idempotency_key", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "idempotency_key", "join_hints": [], "keywords": ["idempotency", "key"], "semantics": null}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.created_at", "doc_type": "schema_column", "text": "Column: UserResearchEvent.created_at (table user_research_events) — datetime Used to track or store timestamp when record was created. Required field. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "created_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: userresearchevent created at in specific year or date range. Query user_research_events table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchevent created at in the last week. Query user_research_events table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.user_research_event.UserResearchEvent.updated_at", "doc_type": "schema_column", "text": "Column: UserResearchEvent.updated_at (table user_research_events) — datetime Used to track or store timestamp when record was last updated. Required field. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "updated_at", "type": "DATETIME", "nullable": false, "source_file": "backend/models/user_research_event.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: userresearchevent updated at recently. Query user_research_events table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchevent updated at in the last week. Query user_research_events table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:all_user_research_events", "doc_type": "query_recipe", "text": "Recipe: all userresearchevents. Query user_research_events table. Use SELECT * FROM user_research_events or SELECT specific columns. Optionally filter by conditions if specified. Return all records from user_research_events.", "metadata": {"model": "UserResearchEvent", "table": "user_research_events", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "userresearchevent"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "schema_model:models.user_research_profile.UserResearchProfile", "doc_type": "schema_model", "text": "Model: UserResearchProfile (table user_research_profiles) — Research profile describing the local user's goals and preferences. This model stores research goals, questions, and related information. Key columns: user id (identifier), last session id (identifier), display name (name or label for identification), created at (timestamp when record was created), updated at (timestamp when record was last updated) Commonly used for: research goals and questions, temporal queries and filtering Example queries: 'userresearchprofile goals', 'userresearchprofile questions', 'userresearchprofile names'", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "source_file": "backend/models/user_research_profile.py"}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.id", "doc_type": "schema_column", "text": "Column: UserResearchProfile.id (table user_research_profiles) — varchar Used to track or store data field. Required field. Default: function generate_uuid.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["id"]}}
{"id": "query_recipe:user_research_profiles.id", "doc_type": "query_recipe", "text": "Recipe: access id from user_research_profiles. Filter by user_research_profiles.id to find specific records.. Return UserResearchProfile.id", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "id", "join_hints": [], "keywords": ["id"], "semantics": null}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.user_id", "doc_type": "schema_column", "text": "Column: UserResearchProfile.user_id (table user_research_profiles) — varchar foreign key identifier Used to track or store identifier. Required field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "user_id", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["id", "user"]}}
{"id": "query_recipe:user_research_profiles.user_id", "doc_type": "query_recipe", "text": "Recipe: access user_id from user_research_profiles. Filter by user_research_profiles.user_id to find specific records.. Return UserResearchProfile.user_id", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "user_id", "join_hints": [], "keywords": ["id", "user"], "semantics": null}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.last_session_id", "doc_type": "schema_column", "text": "Column: UserResearchProfile.last_session_id (table user_research_profiles) — varchar foreign key identifier Used to track or store identifier.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "last_session_id", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["id", "last", "session"]}}
{"id": "query_recipe:user_research_profiles.last_session_id", "doc_type": "query_recipe", "text": "Recipe: access last_session_id from user_research_profiles. Filter by user_research_profiles.last_session_id to find specific records.. Return UserResearchProfile.last_session_id", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "last_session_id", "join_hints": [], "keywords": ["id", "last", "session"], "semantics": null}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.display_name", "doc_type": "schema_column", "text": "Column: UserResearchProfile.display_name (table user_research_profiles) — varchar name or label Used to track or store name or label for identification. Required field. Default: Local Researcher. Common query patterns: WHERE display_name = 'value' for exact match, WHERE display_name LIKE 'pattern%' for pattern matching.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "display_name", "type": "VARCHAR", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["display", "label", "labels", "name", "names", "title", "titles"]}}
{"id": "query_recipe:user_research_profiles.display_name", "doc_type": "query_recipe", "text": "Recipe: access display_name from user_research_profiles. Filter by user_research_profiles.display_name to find specific records.. Return UserResearchProfile.display_name", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "display_name", "join_hints": [], "keywords": ["display", "label", "labels", "name", "names", "title", "titles"], "semantics": null}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.role", "doc_type": "schema_column", "text": "Column: UserResearchProfile.role (table user_research_profiles) — varchar Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "role", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["role"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.organization", "doc_type": "schema_column", "text": "Column: UserResearchProfile.organization (table user_research_profiles) — varchar Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "organization", "type": "VARCHAR", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["organization"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.background", "doc_type": "schema_column", "text": "Column: UserResearchProfile.background (table user_research_profiles) — text Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "background", "type": "TEXT", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["background"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.research_interests", "doc_type": "schema_column", "text": "Column: UserResearchProfile.research_interests (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "research_interests", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["interests", "research"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.current_focus", "doc_type": "schema_column", "text": "Column: UserResearchProfile.current_focus (table user_research_profiles) — text Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "current_focus", "type": "TEXT", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["current", "focus"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.short_term_goals", "doc_type": "schema_column", "text": "Column: UserResearchProfile.short_term_goals (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "short_term_goals", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["goals", "short", "term"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.long_term_goals", "doc_type": "schema_column", "text": "Column: UserResearchProfile.long_term_goals (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "long_term_goals", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["goals", "long", "term"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.preferred_modalities", "doc_type": "schema_column", "text": "Column: UserResearchProfile.preferred_modalities (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "preferred_modalities", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["modalities", "preferred"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.collaboration_style", "doc_type": "schema_column", "text": "Column: UserResearchProfile.collaboration_style (table user_research_profiles) — text Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "collaboration_style", "type": "TEXT", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["collaboration", "style"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.success_indicators", "doc_type": "schema_column", "text": "Column: UserResearchProfile.success_indicators (table user_research_profiles) — JSON object Used to track or store number of successful operations. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "success_indicators", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["indicators", "succeeded", "success", "win", "wins"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.support_needs", "doc_type": "schema_column", "text": "Column: UserResearchProfile.support_needs (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "support_needs", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["needs", "support"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.knowledge_assets", "doc_type": "schema_column", "text": "Column: UserResearchProfile.knowledge_assets (table user_research_profiles) — JSON object Used to track or store data field. Required field. Default: function list.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "knowledge_assets", "type": "JSON", "nullable": false, "source_file": "backend/models/user_research_profile.py", "keywords": ["assets", "knowledge"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.notes", "doc_type": "schema_column", "text": "Column: UserResearchProfile.notes (table user_research_profiles) — text Used to track or store data field.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "notes", "type": "TEXT", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["notes"]}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.created_at", "doc_type": "schema_column", "text": "Column: UserResearchProfile.created_at (table user_research_profiles) — datetime Used to track or store timestamp when record was created. Default: function utc_now. Common query patterns: WHERE created_at >= date for temporal filtering, ORDER BY created_at DESC for recent records.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "created_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["at", "begin", "created", "creation", "new", "started"]}}
{"id": "query_recipe:created_at_in_year", "doc_type": "query_recipe", "text": "Recipe: userresearchprofile created at in specific year or date range. Query user_research_profiles table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= start_date AND created_at <= end_date. Return matching records.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "date", "in", "new", "started", "when", "year"], "semantics": "Temporal filtering by year or date range", "recipe_type": "temporal"}}
{"id": "query_recipe:created_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchprofile created at in the last week. Query user_research_profiles table. Filter by created_at >= NOW() - INTERVAL '7' DAYS or WHERE created_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "created_at", "join_hints": [], "keywords": ["at", "begin", "created", "creation", "last week", "new", "past", "recent", "since", "started"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "schema_column:models.user_research_profile.UserResearchProfile.updated_at", "doc_type": "schema_column", "text": "Column: UserResearchProfile.updated_at (table user_research_profiles) — datetime Used to track or store timestamp when record was last updated. Default: function utc_now. Common query patterns: WHERE updated_at >= date for temporal filtering, ORDER BY updated_at DESC for recent records.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "updated_at", "type": "DATETIME", "nullable": true, "source_file": "backend/models/user_research_profile.py", "keywords": ["at", "changed", "modified", "recent", "recently", "update", "updated"]}}
{"id": "query_recipe:updated_at_recently", "doc_type": "query_recipe", "text": "Recipe: userresearchprofile updated at recently. Query user_research_profiles table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL 'N' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 'N' DAYS). Order by updated_at DESC to show most recent first. Return recently updated records.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "latest", "modified", "recent", "recently", "update", "updated"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal"}}
{"id": "query_recipe:updated_at_last_week", "doc_type": "query_recipe", "text": "Recipe: userresearchprofile updated at in the last week. Query user_research_profiles table. Filter by updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Return records from the last week.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "updated_at", "join_hints": [], "keywords": ["at", "changed", "last week", "modified", "past", "recent", "recently", "since", "update", "updated"], "semantics": "Temporal filtering for last week", "recipe_type": "temporal"}}
{"id": "query_recipe:list_all_user_research_profiles_names", "doc_type": "query_recipe", "text": "Recipe: list all userresearchprofile names. Query user_research_profiles table. Use SELECT display_name FROM user_research_profiles. Optionally filter by conditions if specified. Order by display_name ASC for alphabetical order. Return all display_name values.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": "display_name", "join_hints": [], "keywords": ["all", "display", "label", "labels", "list", "list all", "name", "names", "title", "titles"], "semantics": "Simple SELECT query for names", "recipe_type": "generic"}}
{"id": "query_recipe:all_user_research_profiles", "doc_type": "query_recipe", "text": "Recipe: all userresearchprofiles. Query user_research_profiles table. Use SELECT * FROM user_research_profiles or SELECT specific columns. Optionally filter by conditions if specified. Return all records from user_research_profiles.", "metadata": {"model": "UserResearchProfile", "table": "user_research_profiles", "column": null, "join_hints": [], "keywords": ["all", "every", "list", "userresearchprofile"], "semantics": "Simple SELECT all query", "recipe_type": "generic"}}
{"id": "query_recipe:success_count_for_program_name", "doc_type": "query_recipe", "text": "Recipe: success count for a named program. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name. Return program_statistics.success_count. If multiple rows exist due to variants (variant_id), either sum across rows or choose variant_id IS NULL depending on requested semantics.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "success_count", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["success", "count", "program", "name"], "semantics": "variant_id may require sum vs base-only"}}
{"id": "query_recipe:success_count_for_program_with_variants", "doc_type": "query_recipe", "text": "Recipe: success count for a named program with variant handling. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name. Return program_statistics.success_count. If multiple rows exist due to variants (variant_id), either sum across rows (SUM(success_count)) or choose variant_id IS NULL depending on requested semantics. For base program only, use WHERE variant_id IS NULL. For total across all variants, use SUM(success_count) GROUP BY program_id.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "success_count", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["success", "count", "program", "name", "variant"], "semantics": "variant_id may require sum vs base-only", "source": "curated"}}
{"id": "query_recipe:failure_rate_calculation", "doc_type": "query_recipe", "text": "Recipe: calculate failure rate for a program. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name. Calculate failure rate as: (failure_count / (success_count + failure_count)) * 100. Handle division by zero: if (success_count + failure_count) = 0, return NULL or 0. Return the calculated failure rate as a percentage.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "failure_count", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["failure", "rate", "percentage", "program", "calculation"], "semantics": "Requires calculation: failure_count / (success_count + failure_count) * 100", "source": "curated"}}
{"id": "query_recipe:avg_execution_time_across_variants", "doc_type": "query_recipe", "text": "Recipe: average execution time for a program across all variants. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name. Aggregate: AVG(avg_execution_time) grouped by program_id. If you want base program only (no variants), add filter variant_id IS NULL. If you want average across all variants, use AVG(avg_execution_time) without variant_id filter. Return the average execution time in seconds.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "avg_execution_time", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["average", "execution", "time", "program", "variant", "avg"], "semantics": "Aggregation required: AVG(avg_execution_time) with optional variant_id filter", "source": "curated"}}
{"id": "query_recipe:program_usage_trends", "doc_type": "query_recipe", "text": "Recipe: program usage trends over time. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name if specified. Filter by time using updated_at or last_used_at columns. Group by time period (day/week/month) using DATE functions. Return usage_count aggregated by time period. For trends, order by time period ascending to show progression over time.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "usage_count", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (optional filter)", "program_statistics.updated_at (time filter)", "program_statistics.last_used_at (time filter)"], "keywords": ["usage", "trend", "time", "over time", "history", "pattern"], "semantics": "Time-based aggregation and grouping required", "source": "curated"}}
{"id": "query_recipe:program_execution_history", "doc_type": "query_recipe", "text": "Recipe: execution history for a program. Join programs to program_executions on programs.id = program_executions.program_id. Filter programs.name by the user's program name. Optionally filter by variant_id if specific variant requested. Order by executed_at descending to show most recent executions first. Return execution details: execution_time, success status, error_message if failed, executed_at timestamp. Can aggregate to get count of executions, success rate, average execution time.", "metadata": {"model": "ProgramExecution", "table": "program_executions", "column": "execution_time", "join_hints": ["program_executions.program_id -> programs.id", "programs.name (filter by user's program name)", "program_executions.variant_id (optional filter)"], "keywords": ["execution", "history", "program", "executed", "run"], "semantics": "Join to program_executions table for detailed execution history", "source": "curated"}}
{"id": "query_recipe:how_many_times_run", "doc_type": "query_recipe", "text": "Recipe: how many times was a program run. Join programs to program_statistics on programs.id = program_statistics.program_id. Filter programs.name by the user's program name. Return program_statistics.usage_count. The usage_count column represents how many times the program was run or executed. Use SUM(usage_count) if multiple rows exist due to variants.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "usage_count", "join_hints": ["program_statistics.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["how many", "times", "run", "ran", "usage", "count", "executions", "number"], "semantics": "Aggregation: usage_count represents run count", "recipe_type": "aggregation", "source": "curated"}}
{"id": "query_recipe:programs_with_failures", "doc_type": "query_recipe", "text": "Recipe: programs with less than N failures. Query program_statistics table. Filter by failure_count < N where N is the threshold. Join to programs table on program_statistics.program_id = programs.id to get program names. Return programs.name and program_statistics.failure_count. Order by failure_count ASC to show programs with fewest failures first.", "metadata": {"model": "ProgramStatistics", "table": "program_statistics", "column": "failure_count", "join_hints": ["program_statistics.program_id -> programs.id"], "keywords": ["programs", "with", "less", "than", "failures", "failure", "count", "filter"], "semantics": "Filter by failure_count threshold", "recipe_type": "aggregation", "source": "curated"}}
{"id": "query_recipe:program_variants_for_program", "doc_type": "query_recipe", "text": "Recipe: program variants for a specific program. Join programs to program_variants on programs.id = program_variants.program_id. Filter programs.name by the user's program name. Return program_variants.name or program_variants.id. This shows all variants associated with a specific program.", "metadata": {"model": "ProgramVariant", "table": "program_variants", "column": "name", "join_hints": ["program_variants.program_id -> programs.id", "programs.name (filter by user's program name)"], "keywords": ["program", "variants", "for", "specific", "program", "variant", "related"], "semantics": "Relationship query: variants for program", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:list_all_program_names", "doc_type": "query_recipe", "text": "Recipe: list all program names. Query programs table. Use SELECT name FROM programs. Optionally filter by conditions if specified. Order by name ASC for alphabetical order. Return all program names.", "metadata": {"model": "Program", "table": "programs", "column": "name", "join_hints": [], "keywords": ["list", "all", "program", "names", "list all"], "semantics": "Simple SELECT query for names", "recipe_type": "generic", "source": "curated"}}
{"id": "query_recipe:programs_created_in_year", "doc_type": "query_recipe", "text": "Recipe: programs created in specific year (e.g., 2024). Query programs table. Filter by created_at using date functions: WHERE YEAR(created_at) = year or WHERE created_at >= 'year-01-01' AND created_at < 'year+1-01-01'. Return programs.name and programs.created_at. Order by created_at DESC to show newest first.", "metadata": {"model": "Program", "table": "programs", "column": "created_at", "join_hints": [], "keywords": ["programs", "created", "in", "year", "2024", "creation", "date", "when"], "semantics": "Temporal filtering by year", "recipe_type": "temporal", "source": "curated"}}
{"id": "query_recipe:how_many_simulations_running", "doc_type": "query_recipe", "text": "Recipe: how many simulations are running. Query simulations table. Filter by status = 'running' or status = 'active'. Use COUNT(*) to count how many simulations have running status. Return the count as a number.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["how many", "simulations", "are", "running", "status", "count", "number"], "semantics": "Count by status: running", "recipe_type": "status", "source": "curated"}}
{"id": "query_recipe:simulation_names_and_descriptions", "doc_type": "query_recipe", "text": "Recipe: simulation names and descriptions. Query simulations table. Use SELECT name, description FROM simulations. Optionally filter by conditions if specified. Return simulation name and description columns.", "metadata": {"model": "Simulation", "table": "simulations", "column": "name", "join_hints": [], "keywords": ["simulation", "names", "and", "descriptions", "name", "description"], "semantics": "SELECT multiple columns", "recipe_type": "generic", "source": "curated"}}
{"id": "query_recipe:completed_simulations", "doc_type": "query_recipe", "text": "Recipe: completed simulations. Query simulations table. Filter by status = 'completed' or status = 'done'. Return simulations.name, simulations.status, and simulations.completed_at if available. Order by completed_at DESC to show most recently completed first.", "metadata": {"model": "Simulation", "table": "simulations", "column": "status", "join_hints": [], "keywords": ["completed", "simulations", "status", "done", "finished"], "semantics": "Status filtering: completed", "recipe_type": "status", "source": "curated"}}
{"id": "query_recipe:research_goals", "doc_type": "query_recipe", "text": "Recipe: research goals. Query research table. Use SELECT goals FROM research. Optionally filter by research.name or research.id if specific research project requested. Return research.goals column which contains the goals for research projects.", "metadata": {"model": "Research", "table": "research", "column": "goals", "join_hints": [], "keywords": ["research", "goals", "objective", "objectives", "aim"], "semantics": "Simple SELECT query for goals", "recipe_type": "generic", "source": "curated"}}
{"id": "query_recipe:research_questions_related_experiments", "doc_type": "query_recipe", "text": "Recipe: research questions related experiments. Query research_questions table. Use SELECT related_experiment_ids FROM research_questions. The related_experiment_ids column contains array or list of experiment IDs related to each research question. Optionally join to experiments table on experiment IDs to get experiment details. Filter by research_questions.research_id if specific research project requested.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_experiment_ids", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["research", "questions", "related", "experiments", "linked", "connection", "associated"], "semantics": "Relationship query: experiments related to research questions", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:research_questions_related_simulations", "doc_type": "query_recipe", "text": "Recipe: research questions related simulations. Query research_questions table. Use SELECT related_simulation_ids FROM research_questions. The related_simulation_ids column contains array or list of simulation IDs related to each research question. Optionally join to simulations table on simulation IDs to get simulation details. Filter by research_questions.research_id if specific research project requested.", "metadata": {"model": "ResearchQuestion", "table": "research_questions", "column": "related_simulation_ids", "join_hints": ["research_questions.research_id -> research.id"], "keywords": ["research", "questions", "related", "simulations", "linked", "connection", "associated"], "semantics": "Relationship query: simulations related to research questions", "recipe_type": "relationship", "source": "curated"}}
{"id": "query_recipe:research_updated_recently", "doc_type": "query_recipe", "text": "Recipe: research updated recently. Query research table. Filter by updated_at using time range: WHERE updated_at >= NOW() - INTERVAL '7' DAYS or WHERE updated_at >= date_sub(NOW(), INTERVAL 7 DAY). Order by updated_at DESC to show most recently updated first. Return research.name, research.updated_at, and other relevant fields.", "metadata": {"model": "Research", "table": "research", "column": "updated_at", "join_hints": [], "keywords": ["research", "updated", "recently", "recent", "modified", "changed", "latest"], "semantics": "Temporal filtering for recent updates", "recipe_type": "temporal", "source": "curated"}}
{"id": "query_recipe:experiment_simulation_links", "doc_type": "query_recipe", "text": "Recipe: experiment simulation links. Query experiment_simulations table (or experiments linked to simulations). Join experiments to experiment_simulations on experiments.id = experiment_simulations.experiment_id. Join experiment_simulations to simulations on experiment_simulations.simulation_id = simulations.id. Filter by experiments.name or experiments.id if specific experiment requested. Return experiments.name, simulations.name, and experiment_simulations.iteration.", "metadata": {"model": "ExperimentSimulation", "table": "experiment_simulations", "column": "simulation_id", "join_hints": ["experiment_simulations.experiment_id -> experiments.id", "experiment_simulations.simulation_id -> simulations.id"], "keywords": ["experiment", "simulation", "links", "linked", "related", "connection"], "semantics": "Relationship query: experiments linked to simulations", "recipe_type": "relationship", "source": "curated"}}
